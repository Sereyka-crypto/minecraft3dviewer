<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Admin - Minecraft Layer Viewer</title>
    
    <link rel="icon" type="image/png" href="/skin-avatar.png">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" media="print" onload="this.media='all'">
    
    <noscript>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    </noscript>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js" defer></script>

    <style>
      .upload-box,.upload-container{background:rgba(255,255,255,.05)}#viewer-container,.disclaimer-notification,.loading{position:fixed;display:none}.camera-slider,.layer-slider{outline:0;-webkit-appearance:none}*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}body{font-family:Inter,sans-serif;background:#1a1a1a;color:#fff;overflow:hidden;height:100vh;touch-action:none}@keyframes wave{0%,100%{transform:rotate(0)}25%{transform:rotate(15deg)}75%{transform:rotate(-15deg)}}#main-content{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;text-align:center;padding:20px}.upload-container{backdrop-filter:blur(10px);border:2px dashed rgba(255,255,255,.2);border-radius:20px;padding:40px;max-width:900px;width:95%}h1{font-size:28px;font-weight:700;margin-bottom:10px}.subtitle{font-size:14px;color:rgba(255,255,255,.5);margin-bottom:30px}.upload-section{display:grid;grid-template-columns:repeat(3,1fr);gap:15px;margin-bottom:20px}.upload-box{padding:20px;border-radius:12px;border:2px solid rgba(255,255,255,.1);transition:.3s}.upload-box:hover{border-color:rgba(102,126,234,.5);background:rgba(102,126,234,.1)}.upload-box h3{font-size:14px;margin-bottom:8px;color:#667eea;font-weight:600}.file-status{font-size:11px;color:#4ade80;margin-top:10px;min-height:16px;font-weight:500}input[type=file]{display:none}.upload-button{background:linear-gradient(135deg,#667eea 0,#764ba2 100%);color:#fff;padding:10px 25px;border-radius:50px;font-size:13px;font-weight:600;border:none;cursor:pointer;display:inline-flex;align-items:center;gap:8px;transition:.3s}.upload-button:hover{transform:translateY(-2px);box-shadow:0 5px 20px rgba(102,126,234,.5)}.camera-settings{background:rgba(255,255,255,.05);padding:20px;border-radius:12px;border:2px solid rgba(255,255,255,.1);margin-bottom:20px}.camera-settings h3{font-size:14px;color:#667eea;font-weight:600;margin-bottom:15px}.camera-controls{display:grid;grid-template-columns:1fr 1fr;gap:15px}.camera-control{display:flex;flex-direction:column;gap:8px}.camera-control label{font-size:12px;color:rgba(255,255,255,.7);display:flex;justify-content:space-between;align-items:center}.camera-control-value{font-weight:600;color:#4ade80}.camera-slider{width:100%;height:6px;border-radius:3px;background:rgba(255,255,255,.1)}.camera-slider::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer}.camera-slider::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;border:none}.load-button{background:linear-gradient(135deg,#4ade80 0,#22c55e 100%);color:#fff;padding:16px 45px;border-radius:50px;font-size:16px;font-weight:600;border:none;cursor:pointer;display:none;margin:0 auto;transition:.3s}.load-button:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(74,222,128,.5)}#viewer-container{top:0;left:0;width:100%;height:100%;background:#2a2a2a}.loading{top:50%;left:50%;transform:translate(-50%,-50%);z-index:3000;background:rgba(0,0,0,.9);padding:40px;border-radius:20px}.spinner{border:4px solid rgba(255,255,255,.1);border-top:4px solid #667eea;border-radius:50%;width:60px;height:60px;animation:1s linear infinite spin;margin:0 auto 20px}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.layer-info-top{top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.8);padding:15px 40px;border-radius:15px;font-size:20px;font-weight:600;border:2px solid rgba(255,255,255,.1);position:fixed;display:none;z-index:1000;backdrop-filter:blur(10px)}.arrow-button{top:50%;transform:translateY(-50%);background:rgba(0,0,0,.6);border:2px solid rgba(255,255,255,.2);color:#fff;width:80px;height:80px;border-radius:50%;cursor:pointer;align-items:center;justify-content:center;transition:.3s;position:fixed;display:none;z-index:1000;backdrop-filter:blur(10px)}.arrow-button:hover{background:rgba(102,126,234,.8);transform:translateY(-50%) scale(1.1)}.arrow-button:active{transform:translateY(-50%) scale(.95)}.arrow-left{left:30px}.arrow-right{right:30px}.arrow-button .material-icons{font-size:60px}.material-modal-overlay{top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);backdrop-filter:blur(5px);z-index:2000;align-items:center;justify-content:center;position:fixed;display:none}.material-modal-overlay.active{display:flex}.material-modal{background:rgba(30,30,35,.98);border-radius:15px;width:90%;max-width:680px;max-height:85vh;display:flex;flex-direction:column;border:1px solid rgba(255,255,255,.1);box-shadow:0 20px 60px rgba(0,0,0,.5)}.material-header{padding:20px 25px;border-bottom:1px solid rgba(255,255,255,.1);display:flex;justify-content:space-between;align-items:center}.material-item,.material-table-header{display:grid;grid-template-columns:55px 60px 1fr 110px 130px;gap:15px}.material-header h2{font-size:20px;font-weight:600;color:rgba(255,255,255,.95)}.close-modal{background:0 0;border:none;color:#fff;cursor:pointer;font-size:32px;line-height:1;opacity:.7;transition:opacity .2s;padding:0}.close-modal:hover{opacity:1}.close-modal:active{transform:scale(.9)}.material-table-header{padding:14px 25px;background:rgba(40,40,45,.6);border-bottom:2px solid rgba(255,255,255,.15);font-size:14px;font-weight:700;color:rgba(255,255,255,.85);align-items:center}.material-table-header>div{display:flex;align-items:center;justify-content:center}.material-table-header>div:nth-child(3){justify-content:flex-start;padding-left:5px}.material-list{overflow-y:auto;max-height:calc(85vh - 140px)}.material-item{align-items:center;padding:12px 25px;border-bottom:1px solid rgba(255,255,255,.05);transition:background .2s}.material-item:hover{background:rgba(255,255,255,.04)}.material-item.checked{opacity:.4}.material-checkbox-container{display:flex;justify-content:center;align-items:center}.material-checkbox{width:22px;height:22px;cursor:pointer;accent-color:#4ade80}.material-img-container{width:48px;height:48px;display:flex;align-items:center;justify-content:center}.material-img{width:40px;height:40px;object-fit:contain;image-rendering:pixelated}.material-name{font-size:15px;font-weight:500;color:rgba(255,255,255,.95);text-align:left;padding-left:5px;display:flex;align-items:center}.material-quantity,.material-stacks{text-align:center;display:flex;align-items:center}.material-item.checked .material-name{text-decoration:line-through;color:rgba(255,255,255,.4)}.material-quantity{font-size:15px;color:rgba(255,255,255,.9);font-weight:600;justify-content:center}.material-item.checked .material-quantity,.material-item.checked .material-stacks{text-decoration:line-through;color:rgba(255,255,255,.35)}.material-stacks{font-size:14px;color:rgba(255,255,255,.8);font-weight:500;justify-content:center}.icon-button,.material-toggle{color:#fff;cursor:pointer;transition:.3s;background:rgba(0,0,0,.7);backdrop-filter:blur(10px)}.material-toggle,.right-controls{top:30px;display:none;position:fixed}.material-toggle{left:30px;border:2px solid rgba(255,255,255,.1);width:70px;height:70px;border-radius:15px;align-items:center;justify-content:center;z-index:1500}.material-toggle .material-icons{font-size:36px}.icon-button:hover,.material-toggle:hover{background:rgba(102,126,234,.8);transform:scale(1.1)}.icon-button:active,.material-toggle:active{transform:scale(.95)}.right-controls{right:30px;flex-direction:column;gap:15px;z-index:1000}.icon-button{border:2px solid rgba(255,255,255,.1);width:60px;height:60px;border-radius:15px;display:flex;align-items:center;justify-content:center}.icon-button.active{background:rgba(74,222,128,.8);border-color:rgba(74,222,128,.5)}.icon-button:disabled{opacity:.3;cursor:not-allowed}.layer-slider-container{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.7);padding:20px 40px;border-radius:50px;display:none;z-index:1000;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,.1)}.layer-slider{width:400px;height:8px;border-radius:4px;background:rgba(255,255,255,.2)}.layer-slider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;background:#667eea;cursor:pointer}.layer-slider::-moz-range-thumb{width:24px;height:24px;border-radius:50%;background:#667eea;cursor:pointer;border:none}

      .login-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);display:flex;align-items:center;justify-content:center;z-index:9999}
      .login-screen.hidden{display:none}
      .login-box{background:rgba(255,255,255,.15);backdrop-filter:blur(20px);padding:40px;border-radius:20px;text-align:center;max-width:400px;width:90%}
      .login-box h2{margin-bottom:20px;font-size:24px}
      .login-box input{width:100%;padding:15px;border:2px solid rgba(255,255,255,.3);border-radius:10px;background:rgba(255,255,255,.1);color:#fff;font-size:16px;margin-bottom:15px}
      .login-box input::placeholder{color:rgba(255,255,255,.5)}
      .login-box input:focus{outline:none;border-color:#fff}
      .login-box button{width:100%;padding:15px;background:#fff;color:#667eea;border:none;border-radius:10px;font-size:16px;font-weight:600;cursor:pointer;transition:.3s}
      .login-box button:hover{transform:translateY(-2px);box-shadow:0 5px 20px rgba(0,0,0,.3)}
      .login-error{color:#ff6b6b;font-size:14px;margin-top:10px;display:none}

      @media (max-width:1024px){.camera-controls,.upload-section{grid-template-columns:1fr}.upload-section{gap:10px}.upload-container{padding:30px 20px}h1{font-size:24px}.subtitle{font-size:13px}}
      @media (max-width:768px){.camera-controls,.upload-section{grid-template-columns:1fr}.upload-container{padding:25px 15px}h1{font-size:22px}.subtitle{font-size:12px}.camera-settings,.upload-box{padding:15px}.upload-box h3{font-size:13px}.camera-controls{gap:12px}.layer-slider-container{bottom:20px;padding:12px 30px;border-radius:30px}.layer-slider{width:60vw;height:6px}.arrow-button{width:65px;height:65px}.arrow-button .material-icons{font-size:40px}.arrow-left{left:15px}.arrow-right{right:15px}.icon-button{width:50px;height:50px}.material-toggle{width:60px;height:60px;left:15px;top:15px}.material-toggle .material-icons{font-size:32px}.right-controls{top:15px;right:15px;gap:10px}.layer-info-top{font-size:16px;padding:10px 20px;top:15px}.material-modal{width:100%;height:100%;max-width:none;max-height:100vh;margin:0;border-radius:0}.material-header{padding:15px;position:sticky;top:0;background:#1e1e23;z-index:10}.material-item,.material-table-header{grid-template-columns:40px 45px 1fr 75px;gap:5px;padding:10px 8px}.material-table-header{position:sticky;top:59px;z-index:9;background:#1e1e23;font-size:11px}.material-item>div:nth-child(5),.material-table-header>div:nth-child(5){display:none}.material-list{max-height:none;overflow-y:auto}}
    </style>
</head>
<body>

<div class="login-screen" id="login-screen">
    <div class="login-box">
        <h2>üîê Admin Access</h2>
        <input type="password" id="password-input" placeholder="Enter password">
        <button onclick="login()">Login</button>
        <div class="login-error" id="login-error">Wrong password</div>
    </div>
</div>

<div id="main-content" style="display: none;">
    <div class="upload-container">
        <h1>Viewer</h1>
        <p class="subtitle">Load files</p>

        <div class="upload-section" id="upload-section">
            <div class="upload-box">
                <h3>File 1</h3>
                <input type="file" id="model-input" accept=".zip">
                <label for="model-input" class="upload-button">
                    <span class="material-icons">upload_file</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="model-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 2</h3>
                <input type="file" id="litematic-input" accept=".litematic,.schem,.schematic">
                <label for="litematic-input" class="upload-button">
                    <span class="material-icons">account_tree</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="litematic-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 3</h3>
                <input type="file" id="texture-input" accept=".png,.jpg,.jpeg" multiple>
                <label for="texture-input" class="upload-button">
                    <span class="material-icons">collections</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="texture-status"></div>
            </div>
        </div>

        <div class="camera-settings">
            <h3>Camera Settings</h3>
            <div class="camera-controls">
                <div class="camera-control">
                    <label>
                        <span>Rotation</span>
                        <span class="camera-control-value" id="rotation-value">90¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="rotation-slider" min="0" max="360" value="90">
                </div>
                <div class="camera-control">
                    <label>
                        <span>Tilt</span>
                        <span class="camera-control-value" id="tilt-value">60¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="tilt-slider" min="0" max="90" value="60">
                </div>
            </div>
        </div>

        <button class="load-button" id="load-button">
            <span class="material-icons">play_arrow</span>
            <span>Load</span>
        </button>
    </div>
</div>

<div id="viewer-container"></div>
<div class="loading" id="loading"><div class="spinner"></div><p>Loading...</p></div>

<div class="layer-info-top" id="layer-info-top">Layer 1 / 38</div>

<button class="arrow-button arrow-left" id="arrow-left"><span class="material-icons">chevron_left</span></button>
<button class="arrow-button arrow-right" id="arrow-right"><span class="material-icons">chevron_right</span></button>

<div class="material-modal-overlay" id="material-modal-overlay">
    <div class="material-modal">
        <div class="material-header">
            <h2>‚úÖ Materials List</h2>
            <button class="close-modal" id="close-modal">√ó</button>
        </div>
        <div class="material-table-header">
            <div>‚úÖ</div>
            <div>üñºÔ∏è</div>
            <div>Block</div>
            <div>Quantity</div>
            <div>Stacks</div>
        </div>
        <div class="material-list" id="material-list">
            <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load a litematic file</p>
        </div>
    </div>
</div>

<button class="material-toggle" id="material-toggle" title="Material List"><span class="material-icons">inventory_2</span></button>

<div class="right-controls" id="right-controls">
    <button class="icon-button" id="share-button" title="Share Model"><span class="material-icons">share</span></button>
    <button class="icon-button active" id="current-layer-only" title="Show Current Layer Only"><span class="material-icons">layers</span></button>
    <button class="icon-button" id="ruler-toggle" title="Ruler"><span class="material-icons">straighten</span></button>
    <button class="icon-button" id="fov-toggle" title="FOV"><span class="material-icons">photo_camera</span></button>
    <button class="icon-button" id="reset-camera" title="Camera Reset"><span class="material-icons">cameraswitch</span></button>
    <button class="icon-button" id="toggle-texture" title="Outline" disabled><span class="material-icons">texture</span></button>
</div>

<div class="layer-slider-container" id="layer-slider-container">
    <input type="range" class="layer-slider" id="layer-slider" min="1" max="100" value="1">
</div>

<script>
    const WORKER_URL = 'https://litematic-admin.ksereytube.workers.dev';

    function login() {
        const password = document.getElementById('password-input').value;
        fetch(`${WORKER_URL}/api/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ password })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                localStorage.setItem('adminToken', password);
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-content').style.display = 'flex';
            } else {
                document.getElementById('login-error').style.display = 'block';
            }
        })
        .catch(() => {
            document.getElementById('login-error').style.display = 'block';
        });
    }

    const savedToken = localStorage.getItem('adminToken');
    if (savedToken) {
        fetch(`${WORKER_URL}/api/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ password: savedToken })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-content').style.display = 'flex';
            }
        });
    }

    document.getElementById('password-input').addEventListener('keypress', e => {
        if (e.key === 'Enter') login();
    });

    let scene, camera, renderer, controls;
    let model, allMeshes = [], currentLayer = 1, previousLayer = 1, minY = 0, maxY = 0, totalLayers = 0;
    let modelZip = null, litematicFile = null, defaultTextures = {}, customTextures = {}, textureMap = {}, isCustomMode = false, hasCustomTextures = false;
    let initialCameraX, initialCameraY, initialCameraZ, modelCenter, layerHeight;
    let targetCameraY = 0, targetTargetY = 0, animating = false, userInteracting = false;
    let currentFOV = 40;
    let litematicBlocks = [];
    let rulerActive = false, rulerPoints = [], rulerLine = null, rulerSpheres = [], previewSphere = null, rulerTextSprite = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let cameraMovedSinceLastClick = false;
    let cameraRotation = 90, cameraTilt = 60;
    let showCurrentLayerOnly = true;

    const RENAME_DICT = {
        "Beetroots": "Beetroot",
        "Potatoes": "Potato",
        "Carrots": "Carrot",
        "Wheat Crops": "Wheat",
        "Water Cauldron": "Cauldron"
    };

    const BLOCKS_WITHOUT_TEXTURES = ["Nether Portal", "End Portal", "End Gateway"];

    // –ú–∞–ø–ø–∏–Ω–≥ –±–ª–æ–∫–æ–≤ –Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä
    const TEXTURE_ALIASES = {
        "Water": "water_bucket",
        "Lava": "lava_bucket",
        "Powder Snow": "powder_snow_bucket",
        "Milk": "milk_bucket",
        "Spruce Wall Sign": "spruce_sign",
        "Oak Wall Sign": "oak_sign",
        "Birch Wall Sign": "birch_sign",
        "Jungle Wall Sign": "jungle_sign",
        "Acacia Wall Sign": "acacia_sign",
        "Dark Oak Wall Sign": "dark_oak_sign",
        "Mangrove Wall Sign": "mangrove_sign",
        "Cherry Wall Sign": "cherry_sign",
        "Bamboo Wall Sign": "bamboo_sign",
        "Crimson Wall Sign": "crimson_sign",
        "Warped Wall Sign": "warped_sign",
        "Spruce Hanging Sign": "spruce_hanging_sign",
        "Oak Hanging Sign": "oak_hanging_sign",
        "Birch Hanging Sign": "birch_hanging_sign",
        "Jungle Hanging Sign": "jungle_hanging_sign",
        "Acacia Hanging Sign": "acacia_hanging_sign",
        "Dark Oak Hanging Sign": "dark_oak_hanging_sign",
        "Mangrove Hanging Sign": "mangrove_hanging_sign",
        "Cherry Hanging Sign": "cherry_hanging_sign",
        "Bamboo Hanging Sign": "bamboo_hanging_sign",
        "Crimson Hanging Sign": "crimson_hanging_sign",
        "Warped Hanging Sign": "warped_hanging_sign",
        "Redstone Wall Torch": "redstone_torch",
        "Wall Torch": "torch",
        "Soul Wall Torch": "soul_torch"
    };

    document.getElementById('rotation-slider').addEventListener('input', (e) => {
        cameraRotation = parseInt(e.target.value);
        document.getElementById('rotation-value').textContent = cameraRotation + '¬∞';
    });

    document.getElementById('tilt-slider').addEventListener('input', (e) => {
        cameraTilt = parseInt(e.target.value);
        document.getElementById('tilt-value').textContent = cameraTilt + '¬∞';
    });

    function parseNBT(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        function readByte() { return view.getInt8(offset++); }
        function readShort() { const val = view.getInt16(offset); offset += 2; return val; }
        function readInt() { const val = view.getInt32(offset); offset += 4; return val; }
        function readLong() {
            const high = view.getInt32(offset);
            const low = view.getInt32(offset + 4);
            offset += 8;
            return (BigInt(high) << 32n) | BigInt(low >>> 0);
        }
        function readString() {
            const length = readShort();
            const bytes = new Uint8Array(buffer, offset, length);
            offset += length;
            return new TextDecoder().decode(bytes);
        }

        function readValue(type) {
            switch (type) {
                case 1: return readByte();
                case 2: return readShort();
                case 3: return readInt();
                case 4: return readLong();
                case 8: return readString();
                case 9: return readList();
                case 10: return readCompound();
                case 11: return readIntArray();
                case 12: return readLongArray();
                default: return null;
            }
        }

        function readList() {
            const type = readByte();
            const length = readInt();
            const list = [];
            for (let i = 0; i < length; i++) list.push(readValue(type));
            return list;
        }

        function readCompound() {
            const compound = {};
            while (true) {
                const type = readByte();
                if (type === 0) break;
                const name = readString();
                compound[name] = readValue(type);
            }
            return compound;
        }

        function readIntArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) array.push(readInt());
            return array;
        }

        function readLongArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) array.push(readLong());
            return array;
        }

        readByte();
        readString();
        return readCompound();
    }

    function decodeBlockStates(blockStates, bitsPerEntry, totalBlocks) {
        const blockData = [];
        const mask = (1n << BigInt(bitsPerEntry)) - 1n;

        for (let i = 0; i < totalBlocks; i++) {
            const bitPos = i * bitsPerEntry;
            const longIndex = Math.floor(bitPos / 64);
            const bitOffset = bitPos % 64;

            if (longIndex >= blockStates.length) break;

            let entry = blockStates[longIndex];
            let blockId = Number((entry >> BigInt(bitOffset)) & mask);

            if (bitOffset + bitsPerEntry > 64 && longIndex + 1 < blockStates.length) {
                const bitsInNextLong = (bitOffset + bitsPerEntry) - 64;
                const nextEntry = blockStates[longIndex + 1];
                const nextMask = (1n << BigInt(bitsInNextLong)) - 1n;
                const nextPart = Number(nextEntry & nextMask);
                blockId = blockId | (nextPart << (bitsPerEntry - bitsInNextLong));
            }

            blockData.push(blockId);
        }

        return blockData;
    }

    async function parseLitematic(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const decompressed = pako.ungzip(uint8Array);

            const nbt = parseNBT(decompressed.buffer);

            litematicBlocks = [];
            const blockCounts = {};

            if (nbt.Regions) {
                for (const regionName in nbt.Regions) {
                    const region = nbt.Regions[regionName];

                    if (!region.BlockStates || !region.BlockStatePalette || !region.Size) continue;

                    const blockStates = region.BlockStates;
                    const palette = region.BlockStatePalette;
                    const size = region.Size;

                    const width = Math.abs(Number(size.x));
                    const height = Math.abs(Number(size.y));
                    const length = Math.abs(Number(size.z));
                    const totalBlocks = width * height * length;

                    const bitsPerEntry = Math.max(2, Math.ceil(Math.log2(palette.length)));
                    const blocks = decodeBlockStates(blockStates, bitsPerEntry, totalBlocks);

                    blocks.forEach(blockId => {
                        if (blockId >= 0 && blockId < palette.length) {
                            const block = palette[blockId];
                            let blockName = block.Name;

                            if (blockName.toLowerCase().includes('air')) return;

                            blockName = blockName.replace('minecraft:', '').replace('potted_', '').replace(/_/g, ' ');
                            blockName = blockName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                            blockName = RENAME_DICT[blockName] || blockName;

                            if (BLOCKS_WITHOUT_TEXTURES.includes(blockName)) return;

                            blockCounts[blockName] = (blockCounts[blockName] || 0) + 1;
                        }
                    });
                }
            }

            litematicBlocks = Object.entries(blockCounts)
                .map(([name, count]) => ({ name, count, checked: false }))
                .sort((a, b) => b.count - a.count);

        } catch (error) {
            console.error('Error parsing litematic:', error);
        }
    }

    function formatStacks(count) {
        if (count < 64) return count.toString();
        else if (count === 64) return '1 x 64';
        else {
            const stacks = Math.floor(count / 64);
            const remainder = count % 64;
            return remainder === 0 ? stacks + ' x 64' : stacks + ' x 64 + ' + remainder;
        }
    }

    function updateMaterialList() {
        const list = document.getElementById('material-list');
        if (litematicBlocks.length === 0) {
            list.innerHTML = '<p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load a litematic file</p>';
            return;
        }

        list.innerHTML = litematicBlocks.map((block, i) => {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∞–ª–∏–∞—Å –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞
            const alias = TEXTURE_ALIASES[block.name];
            
            let name1, name2, name3;
            if (alias) {
                // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–ª–∏–∞—Å - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
                name1 = alias + '.png';
                name2 = alias.toLowerCase() + '.png';
                name3 = block.name + '.png';
            } else {
                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ–∏—Å–∫
                name1 = block.name + '.png'; // "Oak Slab.png"
                name2 = block.name.toLowerCase().replace(/ /g, '_') + '.png'; // "oak_slab.png"
                name3 = block.name.toLowerCase().replace(/ /g, '') + '.png'; // "oakslab.png"
            }
            
            return `
                <div class="material-item ${block.checked ? 'checked' : ''}" data-index="${i}">
                    <div class="material-checkbox-container">
                        <input type="checkbox" class="material-checkbox" ${block.checked ? 'checked' : ''}>
                    </div>
                    <div class="material-img-container">
                        <img class="material-img" src="/textures/${name1}" onerror="this.src='/textures/${name2}'; this.onerror=function(){this.src='/textures/${name3}'; this.onerror=function(){this.style.display='none'}}">
                    </div>
                    <div class="material-name">${block.name}</div>
                    <div class="material-quantity">${block.count}</div>
                    <div class="material-stacks">${formatStacks(block.count)}</div>
                </div>
            `;
        }).join('');

        list.querySelectorAll('.material-checkbox').forEach((checkbox, i) => {
            checkbox.addEventListener('change', () => {
                litematicBlocks[i].checked = checkbox.checked;
                checkbox.closest('.material-item').classList.toggle('checked', checkbox.checked);
            });
        });
    }

    document.getElementById('model-input').addEventListener('change', (e) => {
        if (e.target.files[0]) {
            modelZip = e.target.files[0];
            document.getElementById('model-status').textContent = '‚úì ' + modelZip.name;
            document.getElementById('load-button').style.display = 'inline-flex';
        }
    });

    document.getElementById('litematic-input').addEventListener('change', async (e) => {
        if (e.target.files[0]) {
            litematicFile = e.target.files[0];
            document.getElementById('litematic-status').textContent = '‚úì ' + litematicFile.name;
            await parseLitematic(litematicFile);
            updateMaterialList();
        }
    });

    document.getElementById('texture-input').addEventListener('change', (e) => {
        customTextures = {};
        Array.from(e.target.files).forEach(file => {
            if (file.type.startsWith('image/')) customTextures[file.name] = URL.createObjectURL(file);
        });
        hasCustomTextures = Object.keys(customTextures).length > 0;
        if (hasCustomTextures) document.getElementById('texture-status').textContent = '‚úì ' + Object.keys(customTextures).length + ' files';
    });

    document.getElementById('load-button').addEventListener('click', async () => {
        if (!modelZip) { alert('Please select a 3D model ZIP file!'); return; }
        document.getElementById('loading').style.display = 'block';
        document.getElementById('main-content').style.display = 'none';
        if (!scene) initThreeJS();
        await loadModel();
    });

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        camera = new THREE.PerspectiveCamera(currentFOV, innerWidth / innerHeight, 0.1, 10000);
        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.screenSpacePanning = true;
        controls.addEventListener('start', () => { userInteracting = true; animating = false; });
        controls.addEventListener('end', () => { userInteracting = false; });
        controls.addEventListener('change', () => { cameraMovedSinceLastClick = true; });

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        const previewGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const previewMat = new THREE.MeshBasicMaterial({ color: 0x4ade80, transparent: true, opacity: 0.6, depthTest: false });
        previewSphere = new THREE.Mesh(previewGeom, previewMat);
        previewSphere.visible = false;
        previewSphere.renderOrder = 999;
        scene.add(previewSphere);

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (animating && !userInteracting) {
            const deltaY = targetCameraY - camera.position.y;
            const deltaTargetY = targetTargetY - controls.target.y;
            if (Math.abs(deltaY) > 0.01 || Math.abs(deltaTargetY) > 0.01) {
                camera.position.y += deltaY * 0.08;
                controls.target.y += deltaTargetY * 0.08;
            } else {
                camera.position.y = targetCameraY;
                controls.target.y = targetTargetY;
                animating = false;
            }
        }
        if (rulerTextSprite && rulerTextSprite.visible) rulerTextSprite.lookAt(camera.position);
        controls.update();
        renderer.render(scene, camera);
    }

    async function loadModel() {
        try {
            const zip = await JSZip.loadAsync(modelZip);
            let objContent = null, mtlContent = null;
            defaultTextures = {};

            for (const [filename, file] of Object.entries(zip.files)) {
                if (file.dir) continue;
                const name = filename.toLowerCase();
                if (name.endsWith('.obj')) objContent = await file.async('text');
                else if (name.endsWith('.mtl')) mtlContent = await file.async('text');
                else if (name.match(/\.(png|jpg|jpeg)$/i)) {
                    const texName = filename.split('/').pop().split('\\').pop();
                    defaultTextures[texName] = URL.createObjectURL(await file.async('blob'));
                }
            }

            if (!objContent) { alert('No OBJ file!'); location.reload(); return; }

            if (mtlContent) {
                let currentMaterial = null;
                mtlContent.split('\n').forEach(line => {
                    const t = line.trim();
                    if (t.startsWith('newmtl ')) currentMaterial = t.substring(7).trim();
                    else if (currentMaterial && t.startsWith('map_Kd ')) {
                        textureMap[currentMaterial] = t.substring(7).trim().split('/').pop().split('\\').pop();
                    }
                });
            }

            const manager = new THREE.LoadingManager();
            manager.setURLModifier(url => {
                const fn = url.split('/').pop().split('\\').pop();
                if (defaultTextures[fn]) return defaultTextures[fn];
                for (const [k, v] of Object.entries(defaultTextures)) {
                    if (k.toLowerCase() === fn.toLowerCase()) return v;
                }
                return url;
            });

            const loader = new THREE.OBJLoader(manager);
            if (mtlContent) {
                const mtlLoader = new THREE.MTLLoader(manager);
                const mtls = mtlLoader.parse(mtlContent);
                mtls.preload();
                for (const [, mat] of Object.entries(mtls.materials)) {
                    mat.side = THREE.DoubleSide;
                    mat.transparent = false;
                    mat.depthWrite = true;
                    mat.alphaTest = 0;
                    mat.opacity = 1.0;
                }
                loader.setMaterials(mtls);
            }

            model = loader.parse(objContent);
            allMeshes = [];
            minY = Infinity; maxY = -Infinity;

            model.traverse(child => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    minY = Math.min(minY, worldPos.y + box.min.y);
                    maxY = Math.max(maxY, worldPos.y + box.max.y);
                    child.frustumCulled = true;
                    child.matrixAutoUpdate = false;
                    child.updateMatrix();
                }
            });

            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            modelCenter = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            totalLayers = Math.ceil(maxY - minY);
            layerHeight = (maxY - minY) / totalLayers;

            const distance = maxDim * 1.8;
            const elevationAngle = cameraTilt * (Math.PI / 180);
            const azimuthAngle = cameraRotation * (Math.PI / 180);
            const firstLayerY = minY + layerHeight;
            const cameraY = firstLayerY + distance * Math.sin(elevationAngle);
            const horizontalDist = distance * Math.cos(elevationAngle);
            const cameraX = modelCenter.x + horizontalDist * Math.cos(azimuthAngle);
            const cameraZ = modelCenter.z + horizontalDist * Math.sin(azimuthAngle);

            initialCameraX = cameraX; initialCameraY = cameraY; initialCameraZ = cameraZ;
            camera.position.set(cameraX, cameraY, cameraZ);
            controls.target.set(modelCenter.x, firstLayerY, modelCenter.z);
            targetCameraY = cameraY;
            targetTargetY = firstLayerY;

            document.getElementById('layer-slider').min = 1;
            document.getElementById('layer-slider').max = totalLayers;
            document.getElementById('layer-slider').value = 1;
            currentLayer = 1; previousLayer = 1;

            updateLayerDisplay();
            updateVisibility();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                document.getElementById('toggle-texture').disabled = false;
                document.getElementById('toggle-texture').classList.add('active');
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('viewer-container').style.display = 'block';
            document.getElementById('layer-info-top').style.display = 'block';
            document.getElementById('arrow-left').style.display = 'flex';
            document.getElementById('arrow-right').style.display = 'flex';
            document.getElementById('material-toggle').style.display = 'flex';
            document.getElementById('right-controls').style.display = 'flex';
            document.getElementById('layer-slider-container').style.display = 'block';
        } catch (error) {
            alert('Error: ' + error.message);
            location.reload();
        }
    }

    function applyTextures() {
        const currentTextures = isCustomMode ? customTextures : defaultTextures;
        allMeshes.forEach(mesh => {
            if (!mesh.material) return;
            const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
            mats.forEach(mat => {
                if (!mat.name) return;
                const texName = textureMap[mat.name];
                if (!texName) return;
                const cleanTexName = texName.split('/').pop().split('\\').pop();
                if (currentTextures[cleanTexName]) {
                    mat.map = new THREE.TextureLoader().load(currentTextures[cleanTexName]);
                    mat.needsUpdate = true;
                }
            });
        });
    }

    function updateCameraHeight() {
        const layerDifference = currentLayer - previousLayer;
        targetCameraY = camera.position.y + layerDifference * layerHeight;
        targetTargetY = controls.target.y + layerDifference * layerHeight;
        previousLayer = currentLayer;
        animating = true;
    }

    function updateVisibility() {
        if (showCurrentLayerOnly) {
            const currentMinY = minY + (currentLayer - 1) * layerHeight;
            const currentMaxY = minY + currentLayer * layerHeight;
            allMeshes.forEach(mesh => {
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                const meshY = worldPos.y + mesh.geometry.boundingBox.max.y;
                mesh.visible = meshY > currentMinY && meshY <= currentMaxY + 0.1;
            });
        } else {
            const currentMaxY = minY + currentLayer * layerHeight;
            allMeshes.forEach(mesh => {
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                mesh.visible = worldPos.y + mesh.geometry.boundingBox.max.y <= currentMaxY + 0.1;
            });
        }
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = 'Layer ' + currentLayer + ' / ' + totalLayers;
    }

    document.getElementById('current-layer-only').addEventListener('click', () => {
        showCurrentLayerOnly = !showCurrentLayerOnly;
        document.getElementById('current-layer-only').classList.toggle('active', showCurrentLayerOnly);
        updateVisibility();
    });

    document.getElementById('layer-slider').addEventListener('input', (e) => {
        currentLayer = parseInt(e.target.value);
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (model) {
            const yOffset = (currentLayer - 1) * layerHeight;
            camera.position.set(initialCameraX, initialCameraY + yOffset, initialCameraZ);
            controls.target.set(modelCenter.x, minY + layerHeight + yOffset, modelCenter.z);
        }
    });

    document.getElementById('toggle-texture').addEventListener('click', () => {
        if (!hasCustomTextures) return;
        isCustomMode = !isCustomMode;
        document.getElementById('toggle-texture').classList.toggle('active', isCustomMode);
        applyTextures();
    });

    document.getElementById('material-toggle').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.add('active');
    });

    document.getElementById('close-modal').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.remove('active');
    });

    document.getElementById('material-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'material-modal-overlay') {
            document.getElementById('material-modal-overlay').classList.remove('active');
        }
    });

    document.getElementById('fov-toggle').addEventListener('click', () => {
        currentFOV = currentFOV === 40 ? 60 : 40;
        camera.fov = currentFOV;
        camera.updateProjectionMatrix();
        document.getElementById('fov-toggle').classList.toggle('active');
    });

    document.getElementById('share-button').addEventListener('click', async () => {
        if (!model || !modelZip) { alert('Please load a model first!'); return; }

        document.getElementById('loading').style.display = 'block';

        try {
            const shareZip = new JSZip();
            shareZip.file('model.zip', modelZip);
            if (litematicFile) shareZip.file('litematic.litematic', litematicFile);

            if (hasCustomTextures) {
                const folder = shareZip.folder('custom_textures');
                for (const [name, url] of Object.entries(customTextures)) {
                    folder.file(name, await (await fetch(url)).blob());
                }
            }

            shareZip.file('metadata.json', JSON.stringify({
                currentLayer, totalLayers,
                hasLitematic: !!litematicFile,
                hasCustomTextures,
                timestamp: Date.now()
            }));

            const blob = await shareZip.generateAsync({ type: 'blob' });
            const fileName = 'model-' + Date.now();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName + '.mcviewer';
            a.click();

            document.getElementById('loading').style.display = 'none';
            prompt('‚úÖ Done!\n\n1. Upload to /shared/ on GitHub\n2. Share link:', 'https://sereyka.com/?view=' + fileName);
        } catch (err) {
            alert('Error: ' + err.message);
            document.getElementById('loading').style.display = 'none';
        }
    });

    addEventListener('resize', () => {
        if (camera && renderer) {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
    });
</script>
</body>
</html>

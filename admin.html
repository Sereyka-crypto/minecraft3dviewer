<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Admin - Minecraft Layer Viewer</title>
    
    <link rel="icon" type="image/png" href="/skin-avatar.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Inter, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Login */
        .login-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .login-screen.hidden { display: none; }
        .login-box {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .login-box h2 { margin-bottom: 20px; }
        .login-box input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .login-box input::placeholder { color: rgba(255,255,255,0.5); }
        .login-box input:focus { outline: none; border-color: #fff; }
        .login-box button {
            width: 100%;
            padding: 15px;
            background: #fff;
            color: #667eea;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        .login-error {
            color: #ff6b6b;
            font-size: 14px;
            margin-top: 10px;
            display: none;
        }

        /* Main */
        #main-content {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 20px;
        }
        #main-content.active { display: flex; }

        .upload-container {
            background: rgba(255,255,255,0.05);
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 900px;
            width: 95%;
        }
        h1 { font-size: 28px; text-align: center; margin-bottom: 10px; }
        .subtitle { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; margin-bottom: 30px; }

        .upload-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .upload-box {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            text-align: center;
            cursor: pointer;
            transition: 0.3s;
        }
        .upload-box:hover {
            border-color: rgba(102,126,234,0.5);
            background: rgba(102,126,234,0.1);
        }
        .upload-box h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 10px;
        }
        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 13px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .file-status {
            font-size: 11px;
            color: #4ade80;
            margin-top: 10px;
            min-height: 16px;
        }
        input[type=file] { display: none; }

        .camera-settings {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            margin-bottom: 20px;
        }
        .camera-settings h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 15px;
        }
        .camera-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .camera-control label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .camera-control-value { font-weight: 600; color: #4ade80; }
        .camera-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }
        .camera-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .load-button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #fff;
            padding: 16px 45px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            display: none;
            margin: 0 auto;
        }

        /* Viewer */
        #viewer-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #2a2a2a;
            display: none;
        }

        .loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            display: none;
            z-index: 3000;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 60px; height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Controls */
        .layer-info-top {
            position: fixed;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 40px;
            border-radius: 15px;
            font-size: 20px;
            font-weight: 600;
            display: none;
            z-index: 1000;
        }
        .arrow-button {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.2);
            color: #fff;
            width: 80px; height: 80px;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .arrow-left { left: 30px; }
        .arrow-right { right: 30px; }
        .arrow-button .material-icons { font-size: 60px; }

        .right-controls {
            position: fixed;
            top: 30px; right: 30px;
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
        }
        .icon-button {
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.1);
            width: 60px; height: 60px;
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-button.active {
            background: rgba(74,222,128,0.8);
        }

        .material-toggle {
            position: fixed;
            top: 30px; left: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.1);
            width: 70px; height: 70px;
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .material-toggle .material-icons { font-size: 36px; }

        .layer-slider-container {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 50px;
            display: none;
            z-index: 1000;
        }
        .layer-slider {
            width: 400px;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            -webkit-appearance: none;
        }
        .layer-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px; height: 24px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        /* Material Modal */
        .material-modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .material-modal-overlay.active { display: flex; }
        .material-modal {
            background: rgba(30,30,35,0.98);
            border-radius: 15px;
            width: 90%;
            max-width: 680px;
            max-height: 85vh;
            overflow: hidden;
        }
        .material-header {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-modal {
            background: none;
            border: none;
            color: #fff;
            font-size: 32px;
            cursor: pointer;
        }
        .material-list {
            padding: 20px;
            max-height: calc(85vh - 80px);
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .upload-section, .camera-controls { grid-template-columns: 1fr; }
            .layer-slider { width: 60vw; }
        }
    </style>
</head>
<body>

<div class="login-screen" id="login-screen">
    <div class="login-box">
        <h2>üîê Admin Access</h2>
        <input type="password" id="password-input" placeholder="Enter password">
        <button onclick="login()">Login</button>
        <div class="login-error" id="login-error">Wrong password</div>
    </div>
</div>

<div id="main-content">
    <div class="upload-container">
        <h1>Viewer</h1>
        <p class="subtitle">Load files</p>

        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('model-input').click()">
                <h3>File 1</h3>
                <button class="upload-button">
                    <span class="material-icons">save</span> Select
                </button>
                <div class="file-status" id="model-status"></div>
                <input type="file" id="model-input" accept=".zip">
            </div>
            <div class="upload-box" onclick="document.getElementById('litematic-input').click()">
                <h3>File 2</h3>
                <button class="upload-button">
                    <span class="material-icons">grid_view</span> Select
                </button>
                <div class="file-status" id="litematic-status"></div>
                <input type="file" id="litematic-input" accept=".litematic">
            </div>
            <div class="upload-box" onclick="document.getElementById('texture-input').click()">
                <h3>File 3</h3>
                <button class="upload-button">
                    <span class="material-icons">image</span> Select
                </button>
                <div class="file-status" id="texture-status"></div>
                <input type="file" id="texture-input" accept="image/*" multiple webkitdirectory>
            </div>
        </div>

        <div class="camera-settings">
            <h3>Camera Settings</h3>
            <div class="camera-controls">
                <div class="camera-control">
                    <label>Rotation <span class="camera-control-value" id="rotation-value">90¬∞</span></label>
                    <input type="range" class="camera-slider" id="camera-rotation" min="0" max="360" value="90">
                </div>
                <div class="camera-control">
                    <label>Tilt <span class="camera-control-value" id="tilt-value">60¬∞</span></label>
                    <input type="range" class="camera-slider" id="camera-tilt" min="0" max="90" value="60">
                </div>
            </div>
        </div>

        <button class="load-button" id="load-button">Load Model</button>
    </div>
</div>

<div id="viewer-container"></div>
<div class="loading" id="loading"><div class="spinner"></div><p>Loading...</p></div>
<div class="layer-info-top" id="layer-info-top">Layer 1 / 1</div>
<button class="arrow-button arrow-left" id="arrow-left"><span class="material-icons">chevron_left</span></button>
<button class="arrow-button arrow-right" id="arrow-right"><span class="material-icons">chevron_right</span></button>
<button class="material-toggle" id="material-toggle"><span class="material-icons">list_alt</span></button>

<div class="right-controls" id="right-controls">
    <button class="icon-button" id="toggle-texture" disabled><span class="material-icons">texture</span></button>
    <button class="icon-button" id="current-layer-only"><span class="material-icons">layers_clear</span></button>
    <button class="icon-button" id="fov-toggle"><span class="material-icons">zoom_out_map</span></button>
    <button class="icon-button" id="reset-camera"><span class="material-icons">center_focus_strong</span></button>
    <button class="icon-button" id="share-button"><span class="material-icons">share</span></button>
</div>

<div class="layer-slider-container" id="layer-slider-container">
    <input type="range" class="layer-slider" id="layer-slider" min="1" max="100" value="1">
</div>

<div class="material-modal-overlay" id="material-modal-overlay">
    <div class="material-modal">
        <div class="material-header">
            <h2>üì¶ Material List</h2>
            <button class="close-modal" id="close-modal">&times;</button>
        </div>
        <div class="material-list" id="material-list">
            <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px;">Load a litematic file</p>
        </div>
    </div>
</div>

<script>
    const WORKER_URL = 'https://litematic-admin.ksereytube.workers.dev';

    function login() {
        const password = document.getElementById('password-input').value;
        fetch(`${WORKER_URL}/api/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ password })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                localStorage.setItem('adminToken', password);
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-content').classList.add('active');
            } else {
                document.getElementById('login-error').style.display = 'block';
            }
        });
    }

    const savedToken = localStorage.getItem('adminToken');
    if (savedToken) {
        fetch(`${WORKER_URL}/api/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ password: savedToken })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-content').classList.add('active');
            }
        });
    }

    document.getElementById('password-input').addEventListener('keypress', e => {
        if (e.key === 'Enter') login();
    });

    let scene, camera, renderer, controls;
    let model, allMeshes = [];
    let minY, maxY, totalLayers, layerHeight;
    let currentLayer = 1, previousLayer = 1;
    let modelCenter, initialCameraX, initialCameraY, initialCameraZ;
    let targetCameraY, targetTargetY;
    let animating = false, userInteracting = false;
    let showCurrentLayerOnly = false;
    let modelZip, litematicFile;
    let customTextures = {}, defaultTextures = {}, textureMap = {};
    let hasCustomTextures = false, isCustomMode = false;
    let litematicBlocks = [];
    let currentFOV = 40;
    let cameraRotation = 90, cameraTilt = 60;

    document.getElementById('camera-rotation').addEventListener('input', e => {
        cameraRotation = parseInt(e.target.value);
        document.getElementById('rotation-value').textContent = cameraRotation + '¬∞';
    });

    document.getElementById('camera-tilt').addEventListener('input', e => {
        cameraTilt = parseInt(e.target.value);
        document.getElementById('tilt-value').textContent = cameraTilt + '¬∞';
    });

    document.getElementById('model-input').addEventListener('change', e => {
        if (e.target.files[0]) {
            modelZip = e.target.files[0];
            document.getElementById('model-status').textContent = '‚úì ' + modelZip.name;
            document.getElementById('load-button').style.display = 'inline-flex';
        }
    });

    document.getElementById('litematic-input').addEventListener('change', async e => {
        if (e.target.files[0]) {
            litematicFile = e.target.files[0];
            document.getElementById('litematic-status').textContent = '‚úì ' + litematicFile.name;
        }
    });

    document.getElementById('texture-input').addEventListener('change', e => {
        customTextures = {};
        Array.from(e.target.files).forEach(file => {
            if (file.type.startsWith('image/')) {
                customTextures[file.name] = URL.createObjectURL(file);
            }
        });
        hasCustomTextures = Object.keys(customTextures).length > 0;
        if (hasCustomTextures) {
            document.getElementById('texture-status').textContent = '‚úì ' + Object.keys(customTextures).length + ' files';
        }
    });

    document.getElementById('load-button').addEventListener('click', async () => {
        if (!modelZip) return alert('Select a model!');
        document.getElementById('loading').style.display = 'block';
        document.getElementById('main-content').classList.remove('active');
        if (!scene) initThreeJS();
        await loadModel();
    });

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        camera = new THREE.PerspectiveCamera(currentFOV, innerWidth / innerHeight, 0.1, 10000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('start', () => { userInteracting = true; animating = false; });
        controls.addEventListener('end', () => { userInteracting = false; });

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (animating && !userInteracting) {
            const deltaY = targetCameraY - camera.position.y;
            const deltaTargetY = targetTargetY - controls.target.y;
            if (Math.abs(deltaY) > 0.01 || Math.abs(deltaTargetY) > 0.01) {
                camera.position.y += deltaY * 0.08;
                controls.target.y += deltaTargetY * 0.08;
            } else {
                camera.position.y = targetCameraY;
                controls.target.y = targetTargetY;
                animating = false;
            }
        }
        controls.update();
        renderer.render(scene, camera);
    }

    async function loadModel() {
        try {
            const zip = await JSZip.loadAsync(modelZip);
            let objContent = null, mtlContent = null;
            defaultTextures = {};

            for (const [filename, file] of Object.entries(zip.files)) {
                if (file.dir) continue;
                const name = filename.toLowerCase();
                if (name.endsWith('.obj')) objContent = await file.async('text');
                else if (name.endsWith('.mtl')) mtlContent = await file.async('text');
                else if (name.match(/\.(png|jpg|jpeg)$/i)) {
                    defaultTextures[filename.split('/').pop()] = URL.createObjectURL(await file.async('blob'));
                }
            }

            if (!objContent) { alert('No OBJ!'); return location.reload(); }

            if (mtlContent) {
                let currentMat = null;
                mtlContent.split('\n').forEach(line => {
                    const t = line.trim();
                    if (t.startsWith('newmtl ')) currentMat = t.substring(7).trim();
                    else if (currentMat && t.startsWith('map_Kd ')) {
                        textureMap[currentMat] = t.substring(7).trim().split('/').pop();
                    }
                });
            }

            const manager = new THREE.LoadingManager();
            manager.setURLModifier(url => {
                const fn = url.split('/').pop();
                return defaultTextures[fn] || url;
            });

            const loader = new THREE.OBJLoader(manager);
            if (mtlContent) {
                const mtls = new THREE.MTLLoader(manager).parse(mtlContent);
                mtls.preload();
                loader.setMaterials(mtls);
            }

            model = loader.parse(objContent);
            allMeshes = [];
            minY = Infinity; maxY = -Infinity;

            model.traverse(child => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const pos = new THREE.Vector3();
                    child.getWorldPosition(pos);
                    minY = Math.min(minY, pos.y + box.min.y);
                    maxY = Math.max(maxY, pos.y + box.max.y);
                }
            });

            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            modelCenter = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            totalLayers = Math.ceil(maxY - minY);
            layerHeight = (maxY - minY) / totalLayers;

            const dist = maxDim * 1.8;
            const elev = cameraTilt * Math.PI / 180;
            const azim = cameraRotation * Math.PI / 180;
            const firstY = minY + layerHeight;
            initialCameraY = firstY + dist * Math.sin(elev);
            const hDist = dist * Math.cos(elev);
            initialCameraX = modelCenter.x + hDist * Math.cos(azim);
            initialCameraZ = modelCenter.z + hDist * Math.sin(azim);

            camera.position.set(initialCameraX, initialCameraY, initialCameraZ);
            controls.target.set(modelCenter.x, firstY, modelCenter.z);
            targetCameraY = initialCameraY;
            targetTargetY = firstY;

            document.getElementById('layer-slider').max = totalLayers;
            currentLayer = 1; previousLayer = 1;
            updateLayerDisplay();
            updateVisibility();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                document.getElementById('toggle-texture').disabled = false;
                document.getElementById('toggle-texture').classList.add('active');
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('viewer-container').style.display = 'block';
            document.getElementById('layer-info-top').style.display = 'block';
            document.getElementById('arrow-left').style.display = 'flex';
            document.getElementById('arrow-right').style.display = 'flex';
            document.getElementById('material-toggle').style.display = 'flex';
            document.getElementById('right-controls').style.display = 'flex';
            document.getElementById('layer-slider-container').style.display = 'block';
        } catch (err) {
            alert('Error: ' + err.message);
            location.reload();
        }
    }

    function applyTextures() {
        const texs = isCustomMode ? customTextures : defaultTextures;
        allMeshes.forEach(mesh => {
            if (!mesh.material) return;
            const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
            mats.forEach(mat => {
                const texName = textureMap[mat.name];
                if (texName && texs[texName]) {
                    mat.map = new THREE.TextureLoader().load(texs[texName]);
                    mat.needsUpdate = true;
                }
            });
        });
    }

    function updateCameraHeight() {
        const diff = currentLayer - previousLayer;
        targetCameraY = camera.position.y + diff * layerHeight;
        targetTargetY = controls.target.y + diff * layerHeight;
        previousLayer = currentLayer;
        animating = true;
    }

    function updateVisibility() {
        if (showCurrentLayerOnly) {
            const minCY = minY + (currentLayer - 1) * layerHeight;
            const maxCY = minY + currentLayer * layerHeight;
            allMeshes.forEach(mesh => {
                const pos = new THREE.Vector3();
                mesh.getWorldPosition(pos);
                const y = pos.y + mesh.geometry.boundingBox.max.y;
                mesh.visible = y > minCY && y <= maxCY + 0.1;
            });
        } else {
            const maxCY = minY + currentLayer * layerHeight;
            allMeshes.forEach(mesh => {
                const pos = new THREE.Vector3();
                mesh.getWorldPosition(pos);
                mesh.visible = pos.y + mesh.geometry.boundingBox.max.y <= maxCY + 0.1;
            });
        }
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = 'Layer ' + currentLayer + ' / ' + totalLayers;
    }

    document.getElementById('current-layer-only').addEventListener('click', () => {
        showCurrentLayerOnly = !showCurrentLayerOnly;
        document.getElementById('current-layer-only').classList.toggle('active', showCurrentLayerOnly);
        updateVisibility();
    });

    document.getElementById('layer-slider').addEventListener('input', e => {
        currentLayer = parseInt(e.target.value);
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (!model) return;
        const off = (currentLayer - 1) * layerHeight;
        camera.position.set(initialCameraX, initialCameraY + off, initialCameraZ);
        controls.target.set(modelCenter.x, minY + layerHeight + off, modelCenter.z);
    });

    document.getElementById('toggle-texture').addEventListener('click', () => {
        if (!hasCustomTextures) return;
        isCustomMode = !isCustomMode;
        document.getElementById('toggle-texture').classList.toggle('active', isCustomMode);
        applyTextures();
    });

    document.getElementById('material-toggle').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.add('active');
    });

    document.getElementById('close-modal').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.remove('active');
    });

    document.getElementById('fov-toggle').addEventListener('click', () => {
        currentFOV = currentFOV === 40 ? 60 : 40;
        camera.fov = currentFOV;
        camera.updateProjectionMatrix();
        document.getElementById('fov-toggle').classList.toggle('active');
    });

    document.getElementById('share-button').addEventListener('click', async () => {
        if (!model || !modelZip) return alert('Load a model first!');
        document.getElementById('loading').style.display = 'block';

        try {
            const shareZip = new JSZip();
            shareZip.file('model.zip', modelZip);
            if (litematicFile) shareZip.file('litematic.litematic', litematicFile);

            if (hasCustomTextures) {
                const folder = shareZip.folder('custom_textures');
                for (const [name, url] of Object.entries(customTextures)) {
                    folder.file(name, await (await fetch(url)).blob());
                }
            }

            shareZip.file('metadata.json', JSON.stringify({
                currentLayer, totalLayers,
                hasLitematic: !!litematicFile,
                hasCustomTextures,
                timestamp: Date.now()
            }));

            const blob = await shareZip.generateAsync({ type: 'blob' });
            const fileName = 'model-' + Date.now();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName + '.mcviewer';
            a.click();

            document.getElementById('loading').style.display = 'none';
            prompt('‚úÖ Done!\n\n1. Upload to /shared/ on GitHub\n2. Share link:', 'https://sereyka.com/?view=' + fileName);
        } catch (err) {
            alert('Error: ' + err.message);
            document.getElementById('loading').style.display = 'none';
        }
    });

    addEventListener('resize', () => {
        if (camera && renderer) {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
    });
</script>
</body>
</html>

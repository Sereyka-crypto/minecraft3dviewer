function updateCameraHeight() {
        const layerDifference = currentLayer - previousLayer;
        const yShift = layerDifference * layerHeight;
        targetCameraY = camera.position.y + yShift;
        targetTargetY = controls.target.y + yShift;
        previousLayer = currentLayer;
        animating = true;
    }

    function updateVisibility() {
        const currentMaxY = minY + currentLayer;
        allMeshes.forEach(mesh => {
            const worldPos = new THREE.Vector3();
            mesh.getWorldPosition(worldPos);
            mesh.visible = (worldPos.y + mesh.geometry.boundingBox.max.y) <= currentMaxY + 0.1;
        });
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = 'Layer ' + currentLayer + ' / ' + totalLayers;
    }

    document.getElementById('layer-slider').addEventListener('input', (e) => {
        currentLayer = parseInt(e.target.value);
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (model) {
            const currentLayerY = minY + (currentLayer * layerHeight);
            const firstLayerY = minY + layerHeight;
            const yOffset = currentLayerY - firstLayerY;
            camera.position.set(initialCameraX, initialCameraY + yOffset, initialCameraZ);
            controls.target.set(modelCenter.x, firstLayerY + yOffset, modelCenter.z);
            targetCameraY = initialCameraY + yOffset;
            targetTargetY = firstLayerY + yOffset;
            animating = false;
            userInteracting = false;
        }
    });

    addEventListener('resize', () => {
        if (camera && renderer) {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
    });

    addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (camera && renderer) {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            }
        }, 100);
    });
</script>

<script src="src/main.js"></script>
</body>
</html>

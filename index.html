<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Minecraft Layer ViewerV6‚öíÔ∏è</title>
    
    <link rel="icon" type="image/png" href="/skin-avatar.png">
    
    <!-- üöÄ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Preconnect –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    
    <!-- üöÄ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Async –∑–∞–≥—Ä—É–∑–∫–∞ —à—Ä–∏—Ñ—Ç–æ–≤ -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" media="print" onload="this.media='all'">
    
    <noscript>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    </noscript>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js" defer></script>

    <style>
      .upload-box,.upload-container{background:rgba(255,255,255,.05)}#viewer-container,.disclaimer-notification,.loading{position:fixed;display:none}.camera-slider,.layer-slider{outline:0;-webkit-appearance:none}*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}body{font-family:Inter,sans-serif;background:#1a1a1a;color:#fff;overflow:hidden;height:100vh;touch-action:none}@keyframes wave{0%,100%{transform:rotate(0)}25%{transform:rotate(15deg)}75%{transform:rotate(-15deg)}}#main-content{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;text-align:center;padding:20px}.upload-container{backdrop-filter:blur(10px);border:2px dashed rgba(255,255,255,.2);border-radius:20px;padding:40px;max-width:900px;width:95%}h1{font-size:28px;font-weight:700;margin-bottom:10px}.subtitle{font-size:14px;color:rgba(255,255,255,.5);margin-bottom:30px}.upload-section{display:grid;grid-template-columns:repeat(3,1fr);gap:15px;margin-bottom:20px}.upload-box{padding:20px;border-radius:12px;border:2px solid rgba(255,255,255,.1);transition:.3s}.upload-box:hover{border-color:rgba(102,126,234,.5);background:rgba(102,126,234,.1)}.upload-box h3{font-size:14px;margin-bottom:8px;color:#667eea;font-weight:600}.file-status{font-size:11px;color:#4ade80;margin-top:10px;min-height:16px;font-weight:500}input[type=file]{display:none}.upload-button{background:linear-gradient(135deg,#667eea 0,#764ba2 100%);color:#fff;padding:10px 25px;border-radius:50px;font-size:13px;font-weight:600;border:none;cursor:pointer;display:inline-flex;align-items:center;gap:8px;transition:.3s}.upload-button:hover{transform:translateY(-2px);box-shadow:0 5px 20px rgba(102,126,234,.5)}.camera-settings{background:rgba(255,255,255,.05);padding:20px;border-radius:12px;border:2px solid rgba(255,255,255,.1);margin-bottom:20px}.camera-settings h3{font-size:14px;color:#667eea;font-weight:600;margin-bottom:15px}.camera-controls{display:grid;grid-template-columns:1fr 1fr;gap:15px}.camera-control{display:flex;flex-direction:column;gap:8px}.camera-control label{font-size:12px;color:rgba(255,255,255,.7);display:flex;justify-content:space-between;align-items:center}.camera-control-value{font-weight:600;color:#4ade80}.camera-slider{width:100%;height:6px;border-radius:3px;background:rgba(255,255,255,.1)}.camera-slider::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer}.camera-slider::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;border:none}.load-button{background:linear-gradient(135deg,#4ade80 0,#22c55e 100%);color:#fff;padding:16px 45px;border-radius:50px;font-size:16px;font-weight:600;border:none;cursor:pointer;display:none;margin:0 auto;transition:.3s}.load-button:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(74,222,128,.5)}#viewer-container{top:0;left:0;width:100%;height:100%;background:#2a2a2a}.loading{top:50%;left:50%;transform:translate(-50%,-50%);z-index:3000;background:rgba(0,0,0,.9);padding:40px;border-radius:20px}.spinner{border:4px solid rgba(255,255,255,.1);border-top:4px solid #667eea;border-radius:50%;width:60px;height:60px;animation:1s linear infinite spin;margin:0 auto 20px}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.disclaimer-notification{bottom:30px;left:30px;background:rgba(30,30,35,.98);border-radius:12px;max-width:400px;width:calc(100% - 60px);padding:20px;border:1px solid rgba(255,255,255,.15);box-shadow:0 10px 40px rgba(0,0,0,.6);z-index:5000;animation:.4s ease-out slideInLeft}.arrow-button,.layer-info-top{z-index:1000;backdrop-filter:blur(10px)}@keyframes slideInLeft{from{opacity:0;transform:translateX(-100px)}to{opacity:1;transform:translateX(0)}}.disclaimer-notification.active{display:block}.disclaimer-notification-header{display:flex;align-items:flex-start;gap:12px;margin-bottom:12px}.disclaimer-notification-icon{font-size:20px;color:#fbbf24;flex-shrink:0;margin-top:2px}.disclaimer-notification-title{font-size:16px;font-weight:600;color:rgba(255,255,255,.95);flex:1}.disclaimer-notification-close{background:0 0;border:none;color:rgba(255,255,255,.5);cursor:pointer;font-size:24px;line-height:1;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;transition:color .2s;flex-shrink:0}.arrow-button,.layer-info-top,.material-modal-overlay{position:fixed;display:none}.disclaimer-notification-close:hover{color:rgba(255,255,255,.9)}.disclaimer-notification-content{color:rgba(255,255,255,.75);font-size:13px;line-height:1.6;padding-left:32px}.layer-info-top{top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.8);padding:15px 40px;border-radius:15px;font-size:20px;font-weight:600;border:2px solid rgba(255,255,255,.1)}.arrow-button{top:50%;transform:translateY(-50%);background:rgba(0,0,0,.6);border:2px solid rgba(255,255,255,.2);color:#fff;width:80px;height:80px;border-radius:50%;cursor:pointer;align-items:center;justify-content:center;transition:.3s}.arrow-button:hover{background:rgba(102,126,234,.8);transform:translateY(-50%) scale(1.1)}.arrow-button:active{transform:translateY(-50%) scale(.95)}.arrow-left{left:30px}.arrow-right{right:30px}.arrow-button .material-icons{font-size:60px}.material-modal-overlay{top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);backdrop-filter:blur(5px);z-index:2000;align-items:center;justify-content:center}.material-modal-overlay.active{display:flex}.material-modal{background:rgba(30,30,35,.98);border-radius:15px;width:90%;max-width:680px;max-height:85vh;display:flex;flex-direction:column;border:1px solid rgba(255,255,255,.1);box-shadow:0 20px 60px rgba(0,0,0,.5)}.material-header{padding:20px 25px;border-bottom:1px solid rgba(255,255,255,.1);display:flex;justify-content:space-between;align-items:center}.material-item,.material-table-header{display:grid;grid-template-columns:55px 60px 1fr 110px 130px;gap:15px}.material-header h2{font-size:20px;font-weight:600;color:rgba(255,255,255,.95)}.close-modal{background:0 0;border:none;color:#fff;cursor:pointer;font-size:32px;line-height:1;opacity:.7;transition:opacity .2s;padding:0}.close-modal:hover{opacity:1}.close-modal:active{transform:scale(.9)}.material-table-header{padding:14px 25px;background:rgba(40,40,45,.6);border-bottom:2px solid rgba(255,255,255,.15);font-size:14px;font-weight:700;color:rgba(255,255,255,.85);align-items:center}.material-table-header>div{display:flex;align-items:center;justify-content:center}.material-table-header>div:nth-child(3){justify-content:flex-start;padding-left:5px}.material-list{overflow-y:auto;max-height:calc(85vh - 140px)}.material-item{align-items:center;padding:12px 25px;border-bottom:1px solid rgba(255,255,255,.05);transition:background .2s}.material-item:hover{background:rgba(255,255,255,.04)}.material-item.checked{opacity:.4}.material-checkbox-container{display:flex;justify-content:center;align-items:center}.material-checkbox{width:22px;height:22px;cursor:pointer;accent-color:#4ade80}.material-img-container{width:48px;height:48px;display:flex;align-items:center;justify-content:center}.material-img{width:40px;height:40px;object-fit:contain;image-rendering:pixelated}.material-name{font-size:15px;font-weight:500;color:rgba(255,255,255,.95);text-align:left;padding-left:5px;display:flex;align-items:center}.material-quantity,.material-stacks{text-align:center;display:flex;align-items:center}.material-item.checked .material-name{text-decoration:line-through;color:rgba(255,255,255,.4)}.material-quantity{font-size:15px;color:rgba(255,255,255,.9);font-weight:600;justify-content:center}.material-item.checked .material-quantity,.material-item.checked .material-stacks{text-decoration:line-through;color:rgba(255,255,255,.35)}.material-stacks{font-size:14px;color:rgba(255,255,255,.8);font-weight:500;justify-content:center}.icon-button,.material-toggle{color:#fff;cursor:pointer;transition:.3s;background:rgba(0,0,0,.7);backdrop-filter:blur(10px)}.material-toggle,.right-controls{top:30px;display:none;position:fixed}.material-toggle{left:30px;border:2px solid rgba(255,255,255,.1);width:70px;height:70px;border-radius:15px;align-items:center;justify-content:center;z-index:1500}.material-toggle .material-icons{font-size:36px}.icon-button:hover,.material-toggle:hover{background:rgba(102,126,234,.8);transform:scale(1.1)}.icon-button:active,.material-toggle:active{transform:scale(.95)}.right-controls{right:30px;flex-direction:column;gap:15px;z-index:1000}.icon-button{border:2px solid rgba(255,255,255,.1);width:60px;height:60px;border-radius:15px;display:flex;align-items:center;justify-content:center}.icon-button.active{background:rgba(74,222,128,.8);border-color:rgba(74,222,128,.5)}.icon-button:disabled{opacity:.3;cursor:not-allowed}.layer-slider-container{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.7);padding:20px 40px;border-radius:50px;display:none;z-index:1000;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,.1)}.layer-slider{width:400px;height:8px;border-radius:4px;background:rgba(255,255,255,.2)}.layer-slider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;background:#667eea;cursor:pointer}.layer-slider::-moz-range-thumb{width:24px;height:24px;border-radius:50%;background:#667eea;cursor:pointer;border:none}@media (max-width:1024px){.camera-controls,.upload-section{grid-template-columns:1fr}.upload-section{gap:10px}.upload-container{padding:30px 20px}h1{font-size:24px}.subtitle{font-size:13px}}@media (max-width:768px){.camera-controls,.upload-section{grid-template-columns:1fr}.loading p,body{font-size:14px}.upload-container{padding:25px 15px}h1{font-size:22px}.subtitle{font-size:12px}.camera-settings,.upload-box{padding:15px}.material-quantity,.upload-box h3{font-size:13px}.camera-controls{gap:12px}.disclaimer-notification{bottom:15px;left:15px;max-width:calc(100% - 30px);padding:16px}.disclaimer-notification-title{font-size:15px}.disclaimer-notification-content{font-size:12px;padding-left:32px}.layer-slider-container{bottom:20px;padding:12px 30px;border-radius:30px;background:rgba(0,0,0,.85)}.layer-slider{width:60vw;height:6px}.layer-slider::-webkit-slider-thumb{width:28px;height:28px}.layer-slider::-moz-range-thumb{width:28px;height:28px}.arrow-button{width:65px;height:65px;border-width:2px}.arrow-button .material-icons{font-size:40px}.arrow-left{left:15px}.arrow-right{right:15px}.icon-button{width:50px;height:50px;border-width:2px}.icon-button .material-icons{font-size:26px}.material-toggle{width:60px;height:60px;left:15px;top:15px}.material-toggle .material-icons{font-size:32px}.right-controls{top:15px;right:15px;gap:10px}.layer-info-top{font-size:16px;padding:10px 20px;top:15px}.material-modal{width:100%;height:100%;max-width:none;max-height:100vh;margin:0;border-radius:0}.material-header{padding:15px;position:sticky;top:0;background:#1e1e23;z-index:10}.material-header h2{font-size:18px}.close-modal{font-size:32px;padding:5px 10px}.material-item,.material-table-header{grid-template-columns:40px 45px 1fr 75px;gap:5px;padding:10px 8px}.material-table-header{position:sticky;top:59px;z-index:9;background:#1e1e23;font-size:11px}.material-item>div:nth-child(5),.material-table-header>div:nth-child(5){display:none}.material-list{max-height:none;overflow-y:auto;-webkit-overflow-scrolling:touch}.material-item{font-size:12px}.material-name{font-size:13px;word-break:break-word}.material-checkbox{width:20px;height:20px}.material-img-container{width:38px;height:38px}.material-img{width:32px;height:32px}.loading{padding:30px 25px}.spinner{width:50px;height:50px}}@media (max-width:480px){h1{font-size:20px}.subtitle{font-size:11px}.disclaimer-notification{bottom:10px;left:10px;max-width:calc(100% - 20px);padding:14px}.layer-slider-container{bottom:15px;padding:10px 25px}.layer-slider{width:55vw}.arrow-button{width:55px;height:55px}.arrow-button .material-icons{font-size:34px}.arrow-left{left:10px}.arrow-right{right:10px}.icon-button{width:45px;height:45px}.icon-button .material-icons{font-size:22px}.material-toggle{width:55px;height:55px;left:10px;top:10px}.material-toggle .material-icons{font-size:28px}.right-controls{top:10px;right:10px;gap:8px}.layer-info-top{font-size:15px;padding:8px 18px;top:10px}.material-item,.material-table-header{grid-template-columns:35px 40px 1fr 70px;gap:4px;font-size:11px;padding:8px 6px}.material-name,.material-quantity{font-size:12px}.material-checkbox{width:18px;height:18px}.material-img-container{width:35px;height:35px}.material-img{width:28px;height:28px}}@media (max-width:900px) and (orientation:landscape){.layer-info-top{top:5px;font-size:13px;padding:6px 12px}.arrow-button{width:50px;height:50px;top:50%}.arrow-button .material-icons{font-size:32px}.arrow-left{left:8px}.arrow-right{right:8px}.icon-button{width:42px;height:42px}.icon-button .material-icons{font-size:22px}.material-toggle{width:45px;height:45px;left:8px;bottom:60px;top:auto}.material-toggle .material-icons{font-size:24px}.right-controls{top:5px;right:8px;gap:6px;flex-direction:row}.layer-slider-container{bottom:5px;padding:8px 20px}.layer-slider{height:6px;width:50vw}.layer-slider::-webkit-slider-thumb{width:24px;height:24px}.layer-slider::-moz-range-thumb{width:24px;height:24px}.disclaimer-notification{bottom:60px;left:8px;max-width:350px}.material-modal{width:100%;height:100%;max-height:100vh}.material-item,.material-table-header{grid-template-columns:35px 40px 1fr 70px 95px;gap:6px;font-size:11px;padding:8px 10px}.material-item>div:nth-child(5),.material-table-header>div:nth-child(5){display:flex!important}.material-name,.material-quantity{font-size:12px}.material-stacks{font-size:11px}.material-checkbox{width:18px;height:18px}.material-img-container{width:35px;height:35px}.material-img{width:30px;height:30px}}@media (max-width:700px) and (max-height:400px) and (orientation:landscape){.layer-info-top{top:3px;font-size:12px;padding:5px 10px}.arrow-button{width:45px;height:45px}.arrow-button .material-icons{font-size:28px}.arrow-left{left:5px}.arrow-right{right:5px}.icon-button{width:38px;height:38px}.icon-button .material-icons{font-size:20px}.material-toggle{width:40px;height:40px;left:5px;bottom:50px}.material-toggle .material-icons{font-size:22px}.right-controls{gap:5px;top:3px;right:5px}.layer-slider-container{bottom:3px;padding:6px 15px}.layer-slider{height:5px;width:45vw}.layer-slider::-webkit-slider-thumb{width:22px;height:22px}.layer-slider::-moz-range-thumb{width:22px;height:22px}.disclaimer-notification{bottom:50px;left:5px;max-width:300px;padding:12px}.material-item,.material-table-header{grid-template-columns:30px 35px 1fr 60px 85px;gap:4px;font-size:10px;padding:6px}.material-name,.material-quantity{font-size:11px}.material-stacks{font-size:10px}.material-img-container{width:30px;height:30px}.material-img{width:26px;height:26px}}
    </style>
</head>
<body>

<div id="welcome-message" style="display: none;">
    <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    ">
        <div style="
            text-align: center;
            max-width: 700px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 60px 40px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        ">
            <span id="secret-emoji" style="
                font-size: 80px;
                margin-bottom: 30px;
                display: block;
                animation: wave 2s ease-in-out infinite;
                cursor: pointer;
            ">üëã</span>
            <h1 style="
                font-size: 42px;
                font-weight: 700;
                margin-bottom: 20px;
                text-shadow: 0 2px 10px rgba(0,0,0,0.2);
            ">Hello there!</h1>
            <p style="
                font-size: 18px;
                opacity: 0.95;
                line-height: 1.8;
                margin-bottom: 15px;
            ">This is a <span style="font-weight: 600; color: #ffd700;">private workspace</span> for Sereyka's projects.</p>
            <p style="
                font-size: 18px;
                opacity: 0.95;
                line-height: 1.8;
                margin-bottom: 15px;
            ">If you received a link to view a specific model, please use that direct link instead.</p>
            <p style="
                margin-top: 30px;
                font-size: 16px;
                opacity: 0.8;
            ">Have a great day! üòä</p>
        </div>
    </div>
</div>

<div id="main-content" style="display: none;">
    <div class="upload-container">
        <h1>Viewer</h1>
        <p class="subtitle">Load files</p>

        <div class="upload-section" id="upload-section">
            <div class="upload-box">
                <h3>File 1</h3>
                <input type="file" id="model-input" accept=".zip">
                <label for="model-input" class="upload-button">
                    <span class="material-icons">upload_file</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="model-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 2</h3>
                <input type="file" id="litematic-input" accept=".litematic,.schem,.schematic">
                <label for="litematic-input" class="upload-button">
                    <span class="material-icons">account_tree</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="litematic-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 3</h3>
                <input type="file" id="texture-input" accept=".png,.jpg,.jpeg" multiple>
                <label for="texture-input" class="upload-button">
                    <span class="material-icons">collections</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="texture-status"></div>
            </div>
        </div>

        <div class="camera-settings">
            <h3>Camera Settings</h3>
            <div class="camera-controls">
                <div class="camera-control">
                    <label>
                        <span>Rotation</span>
                        <span class="camera-control-value" id="rotation-value">90¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="rotation-slider" min="0" max="360" value="90">
                </div>
                <div class="camera-control">
                    <label>
                        <span>Tilt</span>
                        <span class="camera-control-value" id="tilt-value">60¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="tilt-slider" min="0" max="90" value="60">
                </div>
            </div>
        </div>

        <button class="load-button" id="load-button">
            <span class="material-icons">play_arrow</span>
            <span>Load</span>
        </button>
    </div>
</div>

<div class="disclaimer-notification" id="disclaimer-notification">
    <div class="disclaimer-notification-header">
        <span class="disclaimer-notification-icon">‚ö†Ô∏è</span>
        <span class="disclaimer-notification-title">Please note</span>
        <button class="disclaimer-notification-close" id="disclaimer-close">√ó</button>
    </div>
    <div class="disclaimer-notification-content">
        This 3D guide is not a reproduction of the Minecraft¬Æ game. It is an original and independent creation designed to assist players and enhance their building experience. Sereyka Layer Viewer is not affiliated with, endorsed, authorized, or sponsored by Mojang Studios, Microsoft, or any of their affiliates. All rights to Minecraft¬Æ and related assets are owned by Mojang Studios and Microsoft.
    </div>
</div>

<div id="viewer-container"></div>
<div class="loading" id="loading"><div class="spinner"></div><p>Loading...</p></div>

<div class="layer-info-top" id="layer-info-top">Layer 1 / 38</div>

<button class="arrow-button arrow-left" id="arrow-left"><span class="material-icons">chevron_left</span></button>
<button class="arrow-button arrow-right" id="arrow-right"><span class="material-icons">chevron_right</span></button>

<div class="material-modal-overlay" id="material-modal-overlay">
    <div class="material-modal">
        <div class="material-header">
            <h2>‚úÖ Materials List</h2>
            <button class="close-modal" id="close-modal">√ó</button>
        </div>
        <div class="material-table-header">
            <div>‚úÖ</div>
            <div>üñºÔ∏è</div>
            <div>Block</div>
            <div>Quantity</div>
            <div>Stacks</div>
        </div>
        <div class="material-list" id="material-list">
            <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load a litematic file</p>
        </div>
    </div>
</div>

<button class="material-toggle" id="material-toggle" title="Material List"><span class="material-icons">inventory_2</span></button>

<div class="right-controls" id="right-controls">
    <button class="icon-button" id="share-button" title="Share Model"><span class="material-icons">share</span></button>
    <button class="icon-button" id="ruler-toggle" title="Ruler"><span class="material-icons">straighten</span></button>
    <button class="icon-button" id="fov-toggle" title="FOV"><span class="material-icons">photo_camera</span></button>
    <button class="icon-button" id="reset-camera" title="Camera Reset"><span class="material-icons">cameraswitch</span></button>
    <button class="icon-button" id="toggle-texture" title="Outline" disabled><span class="material-icons">texture</span></button>
</div>

<div class="layer-slider-container" id="layer-slider-container">
    <input type="range" class="layer-slider" id="layer-slider" min="1" max="100" value="1">
</div>

<script>
    let scene, camera, renderer, controls;
    let model, allMeshes = [], currentLayer = 1, previousLayer = 1, minY = 0, maxY = 0, totalLayers = 0;
    let modelZip = null, litematicFile = null, defaultTextures = {}, customTextures = {}, textureMap = {}, isCustomMode = false, hasCustomTextures = false;
    let initialCameraX, initialCameraY, initialCameraZ, modelCenter, layerHeight;
    let targetCameraY = 0, targetTargetY = 0, animating = false, userInteracting = false;
    let currentFOV = 40;
    let materials = [];
    let litematicBlocks = [];

    let rulerActive = false;
    let rulerPoints = [];
    let rulerLine = null;
    let rulerSpheres = [];
    let previewSphere = null;
    let rulerTextSprite = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let cameraMovedSinceLastClick = false;

    let cameraRotation = 90;
    let cameraTilt = 60;

    // ‚ö° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Render On Demand
    let needsRender = true;

    function requestRender() {
        needsRender = true;
    }

    const RENAME_DICT = {
        "Beetroots": "Beetroot",
        "Potatoes": "Potato",
        "Carrots": "Carrot",
        "Wheat Crops": "Wheat",
        "Water Cauldron": "Cauldron"
    };

    const BLOCKS_WITHOUT_TEXTURES = [
        "Nether Portal",
        "End Portal",
        "End Gateway"
    ];

    document.getElementById('rotation-slider').addEventListener('input', (e) => {
        cameraRotation = parseInt(e.target.value);
        document.getElementById('rotation-value').textContent = cameraRotation + '¬∞';
    });

    document.getElementById('tilt-slider').addEventListener('input', (e) => {
        cameraTilt = parseInt(e.target.value);
        document.getElementById('tilt-value').textContent = cameraTilt + '¬∞';
    });

    function showDisclaimer() {
        document.getElementById('disclaimer-notification').classList.add('active');
    }

    document.getElementById('disclaimer-close').addEventListener('click', () => {
        document.getElementById('disclaimer-notification').classList.remove('active');
    });

    let clickCount = 0;
    let clickTimer = null;

    window.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const viewFile = urlParams.get('view');
        const adminMode = urlParams.has('admin');
        
        const emoji = document.getElementById('secret-emoji');
        if (emoji) {
            emoji.addEventListener('click', () => {
                clickCount++;
                
                if (clickCount === 1) {
                    clickTimer = setTimeout(() => {
                        clickCount = 0;
                    }, 1000);
                }
                
                if (clickCount === 3) {
                    clearTimeout(clickTimer);
                    clickCount = 0;
                    document.getElementById('welcome-message').style.display = 'none';
                    document.getElementById('main-content').style.display = 'flex';
                }
            });
        }
        
        if (viewFile) {
            console.log('üîó View mode detected:', viewFile);
            
            document.getElementById('main-content').style.display = 'none';
            document.getElementById('welcome-message').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            
            fetch('./shared/' + viewFile + '.mcviewer')
                .then(response => {
                    if (!response.ok) throw new Error('File not found');
                    return response.blob();
                })
                .then(async blob => {
                    const file = new File([blob], viewFile + '.mcviewer');
                    await loadSharedModel(file);
                    
                    setTimeout(() => {
                        showDisclaimer();
                    }, 500);
                    
                    setTimeout(() => {
                        const shareBtn = document.getElementById('share-button');
                        if (shareBtn) shareBtn.style.display = 'none';
                    }, 1000);
                })
                .catch(error => {
                    console.error('‚ùå Load error:', error);
                    alert('‚ùå Model not found. Please check the link.');
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-content').style.display = 'flex';
                });
        }
        else if (adminMode) {
            document.getElementById('welcome-message').style.display = 'none';
            document.getElementById('main-content').style.display = 'flex';
        }
        else {
            document.getElementById('main-content').style.display = 'none';
            document.getElementById('welcome-message').style.display = 'block';
        }
    });

    async function loadSharedModel(file) {
        document.getElementById('loading').style.display = 'block';

        try {
            const zip = await JSZip.loadAsync(file);

            const modelFile = await zip.file('model.zip').async('blob');
            modelZip = new File([modelFile], 'model.zip');

            const litematicZipFile = zip.file('litematic.litematic');
            if (litematicZipFile) {
                const litematicBlob = await litematicZipFile.async('blob');
                litematicFile = new File([litematicBlob], 'litematic.litematic');
                await parseLitematic(litematicFile);
            }

            const customTexturesFolder = zip.folder('custom_textures');
            if (customTexturesFolder) {
                customTextures = {};
                const files = [];
                customTexturesFolder.forEach((relativePath, file) => {
                    if (!file.dir) files.push(file);
                });
                
                console.log('üì¶ Loading', files.length, 'custom textures...');
                
                for (const file of files) {
                    const blob = await file.async('blob');
                    const fileName = file.name.split('/').pop();
                    customTextures[fileName] = URL.createObjectURL(blob);
                    console.log('‚úÖ Loaded texture:', fileName);
                }
                
                if (Object.keys(customTextures).length > 0) {
                    hasCustomTextures = true;
                    console.log('üé® Custom textures loaded:', Object.keys(customTextures).length);
                }
            }

            if (!scene) initThreeJS();
            await loadModel();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                const toggleBtn = document.getElementById('toggle-texture');
                if (toggleBtn) {
                    toggleBtn.disabled = false;
                    toggleBtn.classList.add('active');
                }
                console.log('üé® Custom textures applied automatically');
            }

        } catch (error) {
            console.error('Error loading shared model:', error);
            alert('Error loading shared model. Please make sure the file is valid.');
            document.getElementById('loading').style.display = 'none';
        }
    }

    function formatStacks(count) {
        if (count < 64) {
            return count.toString();
        } else if (count === 64) {
            return '1 x 64';
        } else {
            const stacks = Math.floor(count / 64);
            const remainder = count % 64;
            if (remainder === 0) {
                return stacks + ' x 64';
            } else {
                return stacks + ' x 64 + ' + remainder;
            }
        }
    }

    function parseNBT(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        function readByte() {
            return view.getInt8(offset++);
        }

        function readShort() {
            const val = view.getInt16(offset);
            offset += 2;
            return val;
        }

        function readInt() {
            const val = view.getInt32(offset);
            offset += 4;
            return val;
        }

        function readLong() {
            const high = view.getInt32(offset);
            const low = view.getInt32(offset + 4);
            offset += 8;
            return (BigInt(high) << 32n) | BigInt(low >>> 0);
        }

        function readString() {
            const length = readShort();
            const bytes = new Uint8Array(buffer, offset, length);
            offset += length;
            return new TextDecoder().decode(bytes);
        }

        function readValue(type) {
            switch (type) {
                case 1: return readByte();
                case 2: return readShort();
                case 3: return readInt();
                case 4: return readLong();
                case 8: return readString();
                case 9: return readList();
                case 10: return readCompound();
                case 11: return readIntArray();
                case 12: return readLongArray();
                default: return null;
            }
        }

        function readList() {
            const type = readByte();
            const length = readInt();
            const list = [];
            for (let i = 0; i < length; i++) {
                list.push(readValue(type));
            }
            return list;
        }

        function readCompound() {
            const compound = {};
            while (true) {
                const type = readByte();
                if (type === 0) break;
                const name = readString();
                compound[name] = readValue(type);
            }
            return compound;
        }

        function readIntArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(readInt());
            }
            return array;
        }

        function readLongArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(readLong());
            }
            return array;
        }

        readByte();
        readString();
        return readCompound();
    }

    function decodeBlockStates(blockStates, bitsPerEntry, totalBlocks) {
        const blockData = [];
        const mask = (1n << BigInt(bitsPerEntry)) - 1n;

        for (let i = 0; i < totalBlocks; i++) {
            const bitPos = i * bitsPerEntry;
            const longIndex = Math.floor(bitPos / 64);
            const bitOffset = bitPos % 64;

            if (longIndex >= blockStates.length) break;

            let entry = blockStates[longIndex];
            let blockId = Number((entry >> BigInt(bitOffset)) & mask);

            if (bitOffset + bitsPerEntry > 64 && longIndex + 1 < blockStates.length) {
                const bitsInNextLong = (bitOffset + bitsPerEntry) - 64;
                const nextEntry = blockStates[longIndex + 1];
                const nextMask = (1n << BigInt(bitsInNextLong)) - 1n;
                const nextPart = Number(nextEntry & nextMask);
                blockId = blockId | (nextPart << (bitsPerEntry - bitsInNextLong));
            }

            blockData.push(blockId);
        }

        return blockData;
    }

    async function parseLitematic(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const decompressed = pako.ungzip(uint8Array);

            const nbt = parseNBT(decompressed.buffer);

            litematicBlocks = [];
            const blockCounts = {};

            if (nbt.Regions) {
                for (const regionName in nbt.Regions) {
                    const region = nbt.Regions[regionName];

                    if (!region.BlockStates || !region.BlockStatePalette || !region.Size) {
                        continue;
                    }

                    const blockStates = region.BlockStates;
                    const palette = region.BlockStatePalette;
                    const size = region.Size;

                    const width = Math.abs(Number(size.x));
                    const height = Math.abs(Number(size.y));
                    const length = Math.abs(Number(size.z));
                    const totalBlocks = width * height * length;

                    const bitsPerEntry = Math.max(2, Math.ceil(Math.log2(palette.length)));
                    const blocks = decodeBlockStates(blockStates, bitsPerEntry, totalBlocks);

                    blocks.forEach(blockId => {
                        if (blockId >= 0 && blockId < palette.length) {
                            const block = palette[blockId];
                            let blockName = block.Name;

                            if (blockName.toLowerCase().includes('air')) return;

                            blockName = blockName.replace('minecraft:', '').replace('potted_', '').replace(/_/g, ' ');
                            blockName = blockName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                            blockName = RENAME_DICT[blockName] || blockName;

                            if (BLOCKS_WITHOUT_TEXTURES.includes(blockName)) {
                                return;
                            }

                            blockCounts[blockName] = (blockCounts[blockName] || 0) + 1;
                        }
                    });
                }
            }

            litematicBlocks = Object.entries(blockCounts)
                .map(([name, count]) => ({ name, count, checked: false }))
                .sort((a, b) => b.count - a.count);

            const saved = localStorage.getItem('blockChecks');
            if (saved) {
                const checks = JSON.parse(saved);
                litematicBlocks.forEach(block => {
                    if (checks[block.name] !== undefined) {
                        block.checked = checks[block.name];
                    }
                });
            }
        } catch (error) {
            console.error('Error parsing litematic:', error);
        }
    }

    function createTextSprite(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'white';
        context.font = 'bold 180px Inter, Arial, sans-serif';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 256, 128);

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(6, 3, 1);
        sprite.renderOrder = 1000;

        return sprite;
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        camera = new THREE.PerspectiveCamera(currentFOV, innerWidth / innerHeight, 0.1, 10000);
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true,
            powerPreference: 'high-performance'
        });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.screenSpacePanning = true;

        controls.addEventListener('start', () => {
            userInteracting = true;
            animating = false;
        });

        controls.addEventListener('end', () => {
            userInteracting = false;
        });

        controls.addEventListener('change', () => {
            cameraMovedSinceLastClick = true;
            requestRender();
        });

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        const previewGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const previewMat = new THREE.MeshBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.6,
            depthTest: false
        });
        previewSphere = new THREE.Mesh(previewGeom, previewMat);
        previewSphere.visible = false;
        previewSphere.renderOrder = 999;
        scene.add(previewSphere);

        animate();
    }

    // ‚ö°‚ö°‚ö° –°–£–ü–ï–†-–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –†–ï–ù–î–ï–† ‚ö°‚ö°‚ö°
    function animate() {
        requestAnimationFrame(animate);

        let hasChanges = false;

        if (animating && !userInteracting) {
            const deltaY = targetCameraY - camera.position.y;
            const deltaTargetY = targetTargetY - controls.target.y;

            if (Math.abs(deltaY) > 0.01 || Math.abs(deltaTargetY) > 0.01) {
                camera.position.y += deltaY * 0.08;
                controls.target.y += deltaTargetY * 0.08;
                hasChanges = true;
            } else {
                camera.position.y = targetCameraY;
                controls.target.y = targetTargetY;
                animating = false;
                hasChanges = true;
            }
        }

        if (rulerTextSprite && rulerTextSprite.visible) {
            rulerTextSprite.lookAt(camera.position);
            hasChanges = true;
        }

        if (controls.update()) {
            hasChanges = true;
        }

        // üöÄ –†–ï–ù–î–ï–†–ò–ú –¢–û–õ–¨–ö–û –ï–°–õ–ò –ï–°–¢–¨ –ò–ó–ú–ï–ù–ï–ù–ò–Ø
        if (needsRender || hasChanges) {
            renderer.render(scene, camera);
            needsRender = false;
        }
    }

    document.getElementById('model-input').addEventListener('change', (e) => {
        if (e.target.files[0]) {
            modelZip = e.target.files[0];
            document.getElementById('model-status').textContent = '‚úì ' + modelZip.name;
            document.getElementById('load-button').style.display = 'inline-flex';
        }
    });

    document.getElementById('litematic-input').addEventListener('change', async (e) => {
        if (e.target.files[0]) {
            litematicFile = e.target.files[0];
            document.getElementById('litematic-status').textContent = '‚úì ' + litematicFile.name;
            await parseLitematic(litematicFile);
            updateMaterialList();
        }
    });

    document.getElementById('texture-input').addEventListener('change', (e) => {
        customTextures = {};
        Array.from(e.target.files).forEach(file => {
            if (file.type.startsWith('image/')) customTextures[file.name] = URL.createObjectURL(file);
        });
        hasCustomTextures = Object.keys(customTextures).length > 0;
        if (hasCustomTextures) document.getElementById('texture-status').textContent = '‚úì ' + Object.keys(customTextures).length + ' files';
    });

    document.getElementById('load-button').addEventListener('click', async () => {
        if (!modelZip) {
            alert('Please select a 3D model ZIP file!');
            return;
        }
        document.getElementById('loading').style.display = 'block';
        document.getElementById('main-content').style.display = 'none';
        if (!scene) initThreeJS();
        await loadModel();
        
        setTimeout(() => {
            showDisclaimer();
        }, 500);
    });

    async function loadModel() {
        try {
            const zip = await JSZip.loadAsync(modelZip);
            let objContent = null, mtlContent = null;
            defaultTextures = {};

            for (const [filename, file] of Object.entries(zip.files)) {
                if (file.dir) continue;
                const name = filename.toLowerCase();

                if (name.endsWith('.obj')) {
                    objContent = await file.async('text');
                }
                else if (name.endsWith('.mtl')) {
                    mtlContent = await file.async('text');
                }
                else if (name.match(/\.(png|jpg|jpeg)$/i)) {
                    const texName = filename.split('/').pop().split('\\').pop();
                    defaultTextures[texName] = URL.createObjectURL(await file.async('blob'));
                }
            }

            if (!objContent) { alert('No OBJ file!'); location.reload(); return; }

            if (mtlContent) {
                const lines = mtlContent.split('\n');
                let currentMaterial = null;
                lines.forEach(line => {
                    const t = line.trim();
                    if (t.startsWith('newmtl ')) currentMaterial = t.substring(7).trim();
                    else if (currentMaterial && t.startsWith('map_Kd ')) {
                        textureMap[currentMaterial] = t.substring(7).trim().split('/').pop().split('\\').pop();
                    }
                });
            }

            const manager = new THREE.LoadingManager();
            manager.setURLModifier(url => {
                const fn = url.split('/').pop().split('\\').pop();
                if (defaultTextures[fn]) return defaultTextures[fn];
                for (const [k, v] of Object.entries(defaultTextures)) {
                    if (k.toLowerCase() === fn.toLowerCase()) return v;
                }
                return url;
            });

            const loader = new THREE.OBJLoader(manager);
            if (mtlContent) {
                const mtlLoader = new THREE.MTLLoader(manager);
                const mtls = mtlLoader.parse(mtlContent);
                mtls.preload();
                for (const [, mat] of Object.entries(mtls.materials)) {
                    mat.side = THREE.DoubleSide;
                    mat.transparent = false;
                    mat.depthWrite = true;
                    mat.alphaTest = 0;
                    mat.opacity = 1.0;
                    
                    if (mat.map) {
                        mat.map.magFilter = THREE.LinearFilter;
                        mat.map.minFilter = THREE.LinearMipMapLinearFilter;
                        mat.map.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                    }
                }
                loader.setMaterials(mtls);
            }

            model = loader.parse(objContent);
            allMeshes = [];
            minY = Infinity; maxY = -Infinity;

            // ‚ö°‚ö°‚ö° –°–£–ü–ï–†-–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –î–õ–Ø –ë–û–õ–¨–®–ò–• –ú–û–î–ï–õ–ï–ô ‚ö°‚ö°‚ö°
            const meshDataForLayers = [];

            model.traverse(child => {
                if (child.isMesh) {
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    
                    const meshY = worldPos.y + box.max.y;
                    minY = Math.min(minY, worldPos.y + box.min.y);
                    maxY = Math.max(maxY, worldPos.y + box.max.y);
                    
                    meshDataForLayers.push({
                        mesh: child,
                        y: meshY,
                        worldPos: worldPos.clone()
                    });
                    
                    child.frustumCulled = true;
                    child.matrixAutoUpdate = false;
                    child.updateMatrix();
                    
                    if (child.material) {
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(m => {
                            m.side = THREE.DoubleSide;
                            m.transparent = false;
                            m.depthWrite = true;
                            m.alphaTest = 0;
                            m.opacity = 1.0;
                        });
                    }
                    
                    allMeshes.push(child);
                }
            });

            // ‚ö° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –ø–æ —Å–ª–æ—è–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
            console.log('üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞', allMeshes.length, '–±–ª–æ–∫–æ–≤ –ø–æ —Å–ª–æ—è–º...');

            totalLayers = Math.ceil(maxY - minY);
            layerHeight = (maxY - minY) / totalLayers;

            const meshesPerLayer = new Array(totalLayers + 1).fill(null).map(() => []);

            meshDataForLayers.forEach(data => {
                const layerIndex = Math.floor((data.y - minY) / layerHeight);
                if (layerIndex >= 0 && layerIndex <= totalLayers) {
                    meshesPerLayer[layerIndex].push(data.mesh);
                }
            });

            window.meshesPerLayer = meshesPerLayer;

            console.log('‚úÖ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ë–ª–æ–∫–æ–≤ –ø–æ —Å–ª–æ—è–º:', meshesPerLayer.map(l => l.length));

            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            modelCenter = center;
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            const distance = maxDim * 1.8;
            const elevationAngle = cameraTilt * (Math.PI / 180);
            const azimuthAngle = cameraRotation * (Math.PI / 180);
            const firstLayerY = minY + layerHeight;
            const cameraY = firstLayerY + distance * Math.sin(elevationAngle);
            const horizontalDist = distance * Math.cos(elevationAngle);
            const cameraX = center.x + horizontalDist * Math.cos(azimuthAngle);
            const cameraZ = center.z + horizontalDist * Math.sin(azimuthAngle);

            initialCameraX = cameraX; initialCameraY = cameraY; initialCameraZ = cameraZ;

            camera.position.set(cameraX, cameraY, cameraZ);
            controls.target.set(center.x, firstLayerY, center.z);
            targetCameraY = cameraY;
            targetTargetY = firstLayerY;

            const slider = document.getElementById('layer-slider');
            slider.min = 1; slider.max = totalLayers; slider.value = 1;
            currentLayer = 1; previousLayer = 1;

            updateLayerDisplay();
            updateVisibility();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                document.getElementById('toggle-texture').disabled = false;
                document.getElementById('toggle-texture').classList.add('active');
            }

            if (litematicBlocks.length > 0) {
                updateMaterialList();
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('viewer-container').style.display = 'block';
            document.getElementById('layer-info-top').style.display = 'block';
            document.getElementById('arrow-left').style.display = 'flex';
            document.getElementById('arrow-right').style.display = 'flex';
            document.getElementById('material-toggle').style.display = 'flex';
            document.getElementById('right-controls').style.display = 'flex';
            document.getElementById('layer-slider-container').style.display = 'block';
        } catch (error) {
            alert('Error: ' + error.message);
            console.error(error);
            location.reload();
        }
    }

    function updateMaterialList() {
        if (typeof window.createMaterialsList === 'function') {
            window.createMaterialsList(litematicBlocks);
        }
    }

    function applyTextures() {
        const currentTextures = isCustomMode ? customTextures : defaultTextures;
        allMeshes.forEach(mesh => {
            if (!mesh.material) return;
            const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
            mats.forEach(mat => {
                if (!mat.name) return;
                const texName = textureMap[mat.name];
                if (!texName) return;
                const cleanTexName = texName.split('/').pop().split('\\').pop();
                if (currentTextures[cleanTexName]) {
                    const texture = new THREE.TextureLoader().load(currentTextures[cleanTexName]);
                    texture.magFilter = THREE.LinearFilter;
                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                    mat.map = texture;
                    
                    mat.transparent = false;
                    mat.depthWrite = true;
                    mat.alphaTest = 0;
                    mat.opacity = 1.0;
                    
                    mat.needsUpdate = true;
                    return;
                }
            });
        });
    }

    function snapToBlockEdge(point) {
        return new THREE.Vector3(
            Math.round(point.x),
            Math.round(point.y),
            Math.round(point.z)
        );
    }

    function getStraightLine(p1, p2) {
        const dx = Math.abs(p2.x - p1.x);
        const dy = Math.abs(p2.y - p1.y);
        const dz = Math.abs(p2.z - p1.z);

        if (dx >= dy && dx >= dz) {
            return new THREE.Vector3(p2.x, p1.y, p1.z);
        } else if (dy >= dx && dy >= dz) {
            return new THREE.Vector3(p1.x, p2.y, p1.z);
        } else {
            return new THREE.Vector3(p1.x, p1.y, p2.z);
        }
    }

    function manhattanDistance(p1, p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) + Math.abs(p1.z - p2.z);
    }

    document.getElementById('ruler-toggle').addEventListener('click', () => {
        rulerActive = !rulerActive;
        const btn = document.getElementById('ruler-toggle');
        if (rulerActive) {
            btn.classList.add('active');
            clearRuler();
        } else {
            btn.classList.remove('active');
            clearRuler();
            previewSphere.visible = false;
        }
    });

    function clearRuler() {
        rulerPoints = [];
        if (rulerLine) {
            scene.remove(rulerLine);
            rulerLine = null;
        }
        if (rulerTextSprite) {
            scene.remove(rulerTextSprite);
            rulerTextSprite = null;
        }
        rulerSpheres.forEach(sphere => scene.remove(sphere));
        rulerSpheres = [];
    }

    document.addEventListener('mousemove', (event) => {
        if (!renderer || !renderer.domElement) return;

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (rulerActive && rulerPoints.length < 2) {
            if (intersects.length > 0) {
                const rawPoint = intersects[0].point;
                const snappedPoint = snapToBlockEdge(rawPoint);

                if (rulerPoints.length === 1) {
                    const straightPoint = getStraightLine(rulerPoints[0], snappedPoint);
                    previewSphere.position.copy(straightPoint);
                } else {
                    previewSphere.position.copy(snappedPoint);
                }
                previewSphere.visible = true;
            } else {
                previewSphere.visible = false;
            }
        }
    });

    document.addEventListener('click', (event) => {
        if (!rulerActive || !renderer || !renderer.domElement) return;

        if (rulerPoints.length >= 2) {
            if (!cameraMovedSinceLastClick) {
                clearRuler();
                previewSphere.visible = false;
            }
            cameraMovedSinceLastClick = false;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (intersects.length > 0) {
            const rawPoint = intersects[0].point;
            const snappedPoint = snapToBlockEdge(rawPoint);

            let finalPoint = snappedPoint;

            if (rulerPoints.length === 1) {
                finalPoint = getStraightLine(rulerPoints[0], snappedPoint);
            }

            rulerPoints.push(finalPoint);

            const sphereGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            sphere.position.copy(finalPoint);
            sphere.renderOrder = 999;
            scene.add(sphere);
            rulerSpheres.push(sphere);

            if (rulerPoints.length === 2) {
                previewSphere.visible = false;

                const lineGeom = new THREE.BufferGeometry().setFromPoints(rulerPoints);
                const lineMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 2,
                    depthTest: false
                });
                rulerLine = new THREE.Line(lineGeom, lineMat);
                rulerLine.renderOrder = 998;
                scene.add(rulerLine);

                const distance = manhattanDistance(rulerPoints[0], rulerPoints[1]);

                const midPoint = new THREE.Vector3().addVectors(rulerPoints[0], rulerPoints[1]).multiplyScalar(0.5);
                rulerTextSprite = createTextSprite(distance.toString());
                rulerTextSprite.position.copy(midPoint);
                rulerTextSprite.position.y += 2;
                scene.add(rulerTextSprite);

                cameraMovedSinceLastClick = false;
            }
        }
    });

    let touchMoved = false;

    document.addEventListener('touchstart', (event) => {
        touchMoved = false;
    });

    document.addEventListener('touchmove', (event) => {
        if (!renderer || !renderer.domElement) return;
        touchMoved = true;

        const rect = renderer.domElement.getBoundingClientRect();
        const touch = event.touches[0];
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (rulerActive && rulerPoints.length < 2) {
            if (intersects.length > 0) {
                const rawPoint = intersects[0].point;
                const snappedPoint = snapToBlockEdge(rawPoint);

                if (rulerPoints.length === 1) {
                    const straightPoint = getStraightLine(rulerPoints[0], snappedPoint);
                    previewSphere.position.copy(straightPoint);
                } else {
                    previewSphere.position.copy(snappedPoint);
                }
                previewSphere.visible = true;
            } else {
                previewSphere.visible = false;
            }
        }
    });

    document.addEventListener('touchend', (event) => {
        if (!rulerActive || !renderer || !renderer.domElement || touchMoved) return;

        if (rulerPoints.length >= 2) {
            if (!cameraMovedSinceLastClick) {
                clearRuler();
                previewSphere.visible = false;
            }
            cameraMovedSinceLastClick = false;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        const touch = event.changedTouches[0];
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (intersects.length > 0) {
            const rawPoint = intersects[0].point;
            const snappedPoint = snapToBlockEdge(rawPoint);

            let finalPoint = snappedPoint;

            if (rulerPoints.length === 1) {
                finalPoint = getStraightLine(rulerPoints[0], snappedPoint);
            }

            rulerPoints.push(finalPoint);

            const sphereGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            sphere.position.copy(finalPoint);
            sphere.renderOrder = 999;
            scene.add(sphere);
            rulerSpheres.push(sphere);

            if (rulerPoints.length === 2) {
                previewSphere.visible = false;

                const lineGeom = new THREE.BufferGeometry().setFromPoints(rulerPoints);
                const lineMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 2,
                    depthTest: false
                });
                rulerLine = new THREE.Line(lineGeom, lineMat);
                rulerLine.renderOrder = 998;
                scene.add(rulerLine);

                const distance = manhattanDistance(rulerPoints[0], rulerPoints[1]);

                const midPoint = new THREE.Vector3().addVectors(rulerPoints[0], rulerPoints[1]).multiplyScalar(0.5);
                rulerTextSprite = createTextSprite(distance.toString());
                rulerTextSprite.position.copy(midPoint);
                rulerTextSprite.position.y += 2;
                scene.add(rulerTextSprite);

                cameraMovedSinceLastClick = false;
            }
        }
    });

    document.getElementById('toggle-texture').addEventListener('click', () => {
        if (!hasCustomTextures) return;
        isCustomMode = !isCustomMode;
        const btn = document.getElementById('toggle-texture');
        isCustomMode ? btn.classList.add('active') : btn.classList.remove('active');
        applyTextures();
    });

    document.getElementById('material-toggle').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.toggle('active');
    });

    document.getElementById('close-modal').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.remove('active');
    });

    document.getElementById('material-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'material-modal-overlay') {
            document.getElementById('material-modal-overlay').classList.remove('active');
        }
    });

    document.getElementById('fov-toggle').addEventListener('click', () => {
        currentFOV = currentFOV === 40 ? 60 : 40;
        camera.fov = currentFOV;
        camera.updateProjectionMatrix();
        const btn = document.getElementById('fov-toggle');
        btn.classList.toggle('active');
        requestRender();
    });

    document.getElementById('share-button')?.addEventListener('click', async () => {
        if (!model || !modelZip) {
            alert('Please load a model first!');
            return;
        }

        document.getElementById('loading').style.display = 'block';

        try {
            const shareZip = new JSZip();
            shareZip.file('model.zip', modelZip);

            if (litematicFile) {
                shareZip.file('litematic.litematic', litematicFile);
            }

            if (hasCustomTextures && Object.keys(customTextures).length > 0) {
                console.log('üì¶ Saving', Object.keys(customTextures).length, 'custom textures...');
                const texturesFolder = shareZip.folder('custom_textures');
                for (const [filename, blobUrl] of Object.entries(customTextures)) {
                    const response = await fetch(blobUrl);
                    const blob = await response.blob();
                    texturesFolder.file(filename, blob);
                    console.log('‚úÖ Saved:', filename);
                }
            }

            const metadata = {
                currentLayer: currentLayer,
                totalLayers: totalLayers,
                hasLitematic: !!litematicFile,
                hasCustomTextures: hasCustomTextures,
                customTexturesCount: Object.keys(customTextures).length,
                timestamp: Date.now()
            };
            shareZip.file('metadata.json', JSON.stringify(metadata));

            const blob = await shareZip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const fileName = 'model-' + Date.now();
            a.download = fileName + '.mcviewer';
            a.click();

            document.getElementById('loading').style.display = 'none';

            const shareUrl = window.location.origin + '/?view=' + fileName;
            
            let message = '‚úÖ Share file created!\n\n' +
                'üìù Instructions:\n' +
                '1. Upload ' + fileName + '.mcviewer to /shared/ folder on GitHub\n' +
                '2. Push changes to GitHub\n' +
                '3. Share this link:\n\n' +
                shareUrl;
            
            if (hasCustomTextures) {
                message += '\n\nüé® Custom textures included: ' + Object.keys(customTextures).length;
            }
            
            prompt(message, shareUrl);

        } catch (error) {
            console.error('Share error:', error);
            alert('Error creating share file');
            document.getElementById('loading').style.display = 'none';
        }
    });

    function updateCameraHeight() {
        const layerDifference = currentLayer - previousLayer;
        const yShift = layerDifference * layerHeight;
        targetCameraY = camera.position.y + yShift;
        targetTargetY = controls.target.y + yShift;
        previousLayer = currentLayer;
        animating = true;
    }

    // ‚ö°‚ö°‚ö° –°–£–ü–ï–†-–ë–´–°–¢–†–ê–Ø –í–ò–î–ò–ú–û–°–¢–¨ –ü–û –°–õ–û–Ø–ú ‚ö°‚ö°‚ö°
    function updateVisibility() {
        if (!window.meshesPerLayer) {
            const currentMaxY = minY + currentLayer;
            allMeshes.forEach(mesh => {
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                mesh.visible = (worldPos.y + mesh.geometry.boundingBox.max.y) <= currentMaxY + 0.1;
            });
            return;
        }
        
        let visibleCount = 0;
        
        for (let layer = 0; layer <= totalLayers; layer++) {
            const shouldBeVisible = layer <= currentLayer;
            const meshesInLayer = window.meshesPerLayer[layer];
            
            if (!meshesInLayer) continue;
            
            for (let i = 0; i < meshesInLayer.length; i++) {
                const mesh = meshesInLayer[i];
                if (mesh.visible !== shouldBeVisible) {
                    mesh.visible = shouldBeVisible;
                }
                if (shouldBeVisible) visibleCount++;
            }
        }
        
        console.log('üìä –°–ª–æ–π', currentLayer + '/' + totalLayers, '- –í–∏–¥–∏–º–æ:', visibleCount, '–±–ª–æ–∫–æ–≤');
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = 'Layer ' + currentLayer + ' / ' + totalLayers;
    }

    document.getElementById('layer-slider').addEventListener('input', (e) => {
        currentLayer = parseInt(e.target.value);
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
        requestRender();
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
        requestRender();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
        requestRender();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (model) {
            const currentLayerY = minY + (currentLayer * layerHeight);
            const firstLayerY = minY + layerHeight;
            const yOffset = currentLayerY - firstLayerY;
            camera.position.set(initialCameraX, initialCameraY + yOffset, initialCameraZ);
            controls.target.set(modelCenter.x, firstLayerY + yOffset, modelCenter.z);
            targetCameraY = initialCameraY + yOffset;
            targetTargetY = firstLayerY + yOffset;
            animating = false;
            userInteracting = false;
            requestRender();
        }
    });

    addEventListener('resize', () => {
        if (camera && renderer) {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            requestRender();
        }
    });

    addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (camera && renderer) {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
                requestRender();
            }
        }, 100);
    });
</script>

<script src="src/main.js"></script>
</body>
</html>

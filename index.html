<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minecraft Layer Viewer</title>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Inter', sans-serif; background: #1a1a1a; color: #fff; overflow: hidden; height: 100vh; touch-action: none; }

        #main-content { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; text-align: center; padding: 20px; }
        .upload-container { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 2px dashed rgba(255,255,255,0.2); border-radius: 20px; padding: 40px; max-width: 900px; width: 95%; }
        h1 { font-size: 28px; font-weight: 700; margin-bottom: 10px; }
        .subtitle { font-size: 14px; color: rgba(255,255,255,0.5); margin-bottom: 30px; }

        /* VIEW-ONLY DROP ZONE */
        .view-only-drop-zone {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .view-only-drop-zone.active { display: flex; }
        .drop-zone-content {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border: 3px dashed rgba(102,126,234,0.5);
            border-radius: 20px;
            padding: 60px;
            text-align: center;
            max-width: 600px;
        }
        .drop-zone-content h2 { font-size: 32px; margin-bottom: 20px; }
        .drop-zone-content p { font-size: 18px; color: rgba(255,255,255,0.7); margin-bottom: 30px; }
        .drop-zone-content.drag-over {
            border-color: #4ade80;
            background: rgba(74,222,128,0.1);
        }

        .upload-section { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; }
        .upload-box { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; border: 2px solid rgba(255,255,255,0.1); transition: all 0.3s; }
        .upload-box:hover { border-color: rgba(102,126,234,0.5); background: rgba(102,126,234,0.1); }
        .upload-box h3 { font-size: 14px; margin-bottom: 8px; color: #667eea; font-weight: 600; }
        .upload-box p { font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 15px; line-height: 1.4; }
        .file-status { font-size: 11px; color: #4ade80; margin-top: 10px; min-height: 16px; font-weight: 500; }
        input[type="file"] { display: none; }
        .upload-button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 25px; border-radius: 50px; font-size: 13px; font-weight: 600; border: none; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s; }
        .upload-button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102,126,234,0.5); }
        .load-button { background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%); color: white; padding: 16px 45px; border-radius: 50px; font-size: 16px; font-weight: 600; border: none; cursor: pointer; display: none; margin: 0 auto; transition: all 0.3s; }
        .load-button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(74,222,128,0.5); }

        #viewer-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; background: #2a2a2a; }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 3000; display: none; background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; }
        .spinner { border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid #667eea; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .layer-info-top { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 40px; border-radius: 15px; font-size: 20px; font-weight: 600; z-index: 1000; display: none; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1); }

        .arrow-button { position: fixed; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.2); color: white; width: 80px; height: 80px; border-radius: 50%; cursor: pointer; display: none; align-items: center; justify-content: center; z-index: 1000; transition: all 0.3s; backdrop-filter: blur(10px); }
        .arrow-button:hover { background: rgba(102,126,234,0.8); transform: translateY(-50%) scale(1.1); }
        .arrow-left { left: 30px; }
        .arrow-right { right: 30px; }
        .arrow-button .material-icons { font-size: 60px; }

        .material-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .material-modal-overlay.active { display: flex; }

        .material-modal {
            background: rgba(30, 30, 35, 0.98);
            border-radius: 15px;
            width: 90%;
            max-width: 680px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .material-header { padding: 20px 25px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; }
        .material-header h2 { font-size: 20px; font-weight: 600; color: rgba(255,255,255,0.95); }
        .close-modal { background: none; border: none; color: white; cursor: pointer; font-size: 32px; line-height: 1; opacity: 0.7; transition: opacity 0.2s; }
        .close-modal:hover { opacity: 1; }

        .material-table-header {
            display: grid;
            grid-template-columns: 55px 60px 1fr 110px 130px;
            gap: 15px;
            padding: 14px 25px;
            background: rgba(40, 40, 45, 0.6);
            border-bottom: 2px solid rgba(255,255,255,0.15);
            font-size: 14px;
            font-weight: 700;
            color: rgba(255,255,255,0.85);
            align-items: center;
        }

        .material-table-header > div {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .material-table-header > div:nth-child(3) {
            justify-content: flex-start;
            padding-left: 5px;
        }

        .material-list { overflow-y: auto; max-height: calc(85vh - 140px); }
        .material-item {
            display: grid;
            grid-template-columns: 55px 60px 1fr 110px 130px;
            gap: 15px;
            align-items: center;
            padding: 12px 25px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s;
        }
        .material-item:hover { background: rgba(255,255,255,0.04); }
        .material-item.checked { opacity: 0.4; }

        .material-checkbox-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .material-checkbox {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: #4ade80;
        }

        .material-img-container {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .material-name {
            font-size: 15px;
            font-weight: 500;
            color: rgba(255,255,255,0.95);
            text-align: left;
            padding-left: 5px;
            display: flex;
            align-items: center;
        }
        .material-item.checked .material-name { text-decoration: line-through; color: rgba(255,255,255,0.4); }

        .material-quantity {
            font-size: 15px;
            color: rgba(255,255,255,0.9);
            text-align: center;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-item.checked .material-quantity { text-decoration: line-through; color: rgba(255,255,255,0.35); }

        .material-stacks {
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-item.checked .material-stacks { text-decoration: line-through; color: rgba(255,255,255,0.35); }

        .material-toggle { position: fixed; left: 30px; top: 30px; background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.1); color: white; width: 60px; height: 60px; border-radius: 15px; cursor: pointer; display: none; align-items: center; justify-content: center; z-index: 1500; backdrop-filter: blur(10px); transition: all 0.3s; }
        .material-toggle:hover { background: rgba(102,126,234,0.8); transform: scale(1.1); }

        .right-controls { position: fixed; top: 30px; right: 30px; display: none; flex-direction: column; gap: 15px; z-index: 1000; }
        .icon-button { background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.1); color: white; width: 60px; height: 60px; border-radius: 15px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s; }
        .icon-button:hover { background: rgba(102,126,234,0.8); transform: scale(1.1); }
        .icon-button.active { background: rgba(74,222,128,0.8); border-color: rgba(74,222,128,0.5); }
        .icon-button:disabled { opacity: 0.3; cursor: not-allowed; }

        .layer-slider-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 20px 40px; border-radius: 50px; display: none; z-index: 1000; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1); }
        .layer-slider { width: 400px; height: 8px; border-radius: 4px; background: rgba(255,255,255,0.2); outline: none; -webkit-appearance: none; }
        .layer-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; border-radius: 50%; background: #667eea; cursor: pointer; }

        @media (max-width: 768px) {
            .upload-section { grid-template-columns: 1fr; }
            .layer-slider { width: 250px; }
            .material-modal { width: 95%; max-width: none; }
            .material-table-header, .material-item { grid-template-columns: 50px 55px 1fr 100px 120px; gap: 10px; font-size: 13px; padding: 10px 15px; }
            .material-name { font-size: 14px; }
            .material-quantity { font-size: 14px; }
            .material-stacks { font-size: 13px; }
            .material-img-container { width: 40px; height: 40px; }
            .material-img { width: 32px; height: 32px; }
            .arrow-button { width: 60px; height: 60px; }
            .arrow-button .material-icons { font-size: 40px; }
            .arrow-left { left: 15px; }
            .arrow-right { right: 15px; }
        }
    </style>
</head>
<body>
<div id="main-content">
    <div class="upload-container">
        <h1>üéÆ Minecraft Layer Viewer</h1>
        <p class="subtitle">Load your Minecraft schematics and models</p>

        <div class="upload-section" id="upload-section">
            <div class="upload-box">
                <h3>üì¶ 3D Model</h3>
                <p>ZIP with OBJ, MTL, textures</p>
                <input type="file" id="model-input" accept=".zip">
                <label for="model-input" class="upload-button">
                    <span class="material-icons">upload_file</span>
                    <span>Choose ZIP</span>
                </label>
                <div class="file-status" id="model-status"></div>
            </div>

            <div class="upload-box">
                <h3>üèóÔ∏è Litematic</h3>
                <p>Minecraft schematic file</p>
                <input type="file" id="litematic-input" accept=".litematic,.schem,.schematic">
                <label for="litematic-input" class="upload-button">
                    <span class="material-icons">account_tree</span>
                    <span>Choose File</span>
                </label>
                <div class="file-status" id="litematic-status"></div>
            </div>

            <div class="upload-box">
                <h3>üé® Outline Textures</h3>
                <p>Optional PNG textures</p>
                <input type="file" id="texture-input" accept=".png,.jpg,.jpeg" multiple>
                <label for="texture-input" class="upload-button">
                    <span class="material-icons">collections</span>
                    <span>Choose PNGs</span>
                </label>
                <div class="file-status" id="texture-status"></div>
            </div>
        </div>

        <button class="load-button" id="load-button">
            <span class="material-icons">play_arrow</span>
            <span>Load Model</span>
        </button>
    </div>
</div>

<!-- VIEW-ONLY DROP ZONE -->
<div class="view-only-drop-zone" id="view-only-drop-zone">
    <div class="drop-zone-content" id="drop-zone-content">
        <h2>üéÅ Patreon Viewer Mode</h2>
        <p>Drag & Drop the shared .mcviewer file here to view the model</p>
        <input type="file" id="shared-file-input" accept=".mcviewer" style="display: none;">
        <label for="shared-file-input" class="upload-button">
            <span class="material-icons">folder_open</span>
            <span>Or Click to Browse</span>
        </label>
    </div>
</div>

<div id="viewer-container"></div>
<div class="loading" id="loading"><div class="spinner"></div><p>Loading...</p></div>

<div class="layer-info-top" id="layer-info-top">Layer 1 / 38</div>

<button class="arrow-button arrow-left" id="arrow-left"><span class="material-icons">chevron_left</span></button>
<button class="arrow-button arrow-right" id="arrow-right"><span class="material-icons">chevron_right</span></button>

<div class="material-modal-overlay" id="material-modal-overlay">
    <div class="material-modal">
        <div class="material-header">
            <h2>‚úÖ Materials List</h2>
            <button class="close-modal" id="close-modal">√ó</button>
        </div>
        <div class="material-table-header">
            <div>‚úÖ</div>
            <div>üñºÔ∏è</div>
            <div>Block</div>
            <div>Quantity</div>
            <div>Stacks</div>
        </div>
        <div class="material-list" id="material-list">
            <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load a litematic file</p>
        </div>
    </div>
</div>

<button class="material-toggle" id="material-toggle"><span class="material-icons">list</span></button>

<div class="right-controls" id="right-controls">
    <button class="icon-button" id="share-button" title="Share Model"><span class="material-icons">share</span></button>
    <button class="icon-button" id="ruler-toggle" title="Ruler"><span class="material-icons">straighten</span></button>
    <button class="icon-button" id="fov-toggle" title="FOV"><span class="material-icons">photo_camera</span></button>
    <button class="icon-button" id="reset-camera" title="Reset"><span class="material-icons">refresh</span></button>
    <button class="icon-button" id="toggle-texture" title="Outline" disabled><span class="material-icons">texture</span></button>
</div>

<div class="layer-slider-container" id="layer-slider-container">
    <input type="range" class="layer-slider" id="layer-slider" min="1" max="100" value="1">
</div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    const isViewOnly = urlParams.get('view') === 'patreon';

    let scene, camera, renderer, controls;
    let model, allMeshes = [], currentLayer = 1, previousLayer = 1, minY = 0, maxY = 0, totalLayers = 0;
    let modelZip = null, litematicFile = null, defaultTextures = {}, customTextures = {}, textureMap = {}, isCustomMode = false, hasCustomTextures = false;
    let initialCameraX, initialCameraY, initialCameraZ, modelCenter, layerHeight;
    let targetCameraY = 0, targetTargetY = 0, animating = false, userInteracting = false;
    let currentFOV = 40;
    let materials = [];
    let litematicBlocks = [];

    let rulerActive = false;
    let rulerPoints = [];
    let rulerLine = null;
    let rulerSpheres = [];
    let previewSphere = null;
    let rulerTextSprite = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let cameraMovedSinceLastClick = false;

    const RENAME_DICT = {
        "Beetroots": "Beetroot",
        "Potatoes": "Potato",
        "Carrots": "Carrot",
        "Wheat Crops": "Wheat",
        "Water Cauldron": "Cauldron"
    };

    const BLOCKS_WITHOUT_TEXTURES = [
        "Nether Portal",
        "End Portal",
        "End Gateway"
    ];

    // VIEW-ONLY MODE SETUP
    if (isViewOnly) {
        document.getElementById('upload-section').style.display = 'none';
        document.getElementById('load-button').style.display = 'none';
        document.querySelector('.subtitle').textContent = 'üéÅ Patreon Exclusive Viewer';
        document.getElementById('view-only-drop-zone').classList.add('active');

        // Setup drag & drop
        const dropZone = document.getElementById('drop-zone-content');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.mcviewer')) {
                await loadSharedModel(file);
            } else {
                alert('Please drop a valid .mcviewer file');
            }
        });

        document.getElementById('shared-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await loadSharedModel(file);
            }
        });
    }

    // SHARE BUTTON
    document.getElementById('share-button')?.addEventListener('click', async () => {
        if (!model || !modelZip) {
            alert('Please load a model first!');
            return;
        }

        document.getElementById('loading').style.display = 'block';

        try {
            const shareZip = new JSZip();

            // Add original model ZIP
            shareZip.file('model.zip', modelZip);

            // Add litematic if exists
            if (litematicFile) {
                shareZip.file('litematic.litematic', litematicFile);
            }

            // Add metadata
            const metadata = {
                currentLayer: currentLayer,
                totalLayers: totalLayers,
                hasLitematic: !!litematicFile,
                timestamp: Date.now()
            };
            shareZip.file('metadata.json', JSON.stringify(metadata));

            // Generate share file
            const blob = await shareZip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'model-share.mcviewer';
            a.click();

            document.getElementById('loading').style.display = 'none';

            alert('‚úÖ Share file created! Send this .mcviewer file to your Patreon subscribers.\n\nThey should open: ' + window.location.origin + window.location.pathname + '?view=patreon');

        } catch (error) {
            console.error('Share error:', error);
            alert('Error creating share file');
            document.getElementById('loading').style.display = 'none';
        }
    });

    // LOAD SHARED MODEL
    async function loadSharedModel(file) {
        document.getElementById('loading').style.display = 'block';
        document.getElementById('view-only-drop-zone').style.display = 'none';

        try {
            const zip = await JSZip.loadAsync(file);

            // Load model ZIP
            const modelFile = await zip.file('model.zip').async('blob');
            modelZip = new File([modelFile], 'model.zip');

            // Load litematic if exists
            const litematicZipFile = zip.file('litematic.litematic');
            if (litematicZipFile) {
                const litematicBlob = await litematicZipFile.async('blob');
                litematicFile = new File([litematicBlob], 'litematic.litematic');
                await parseLitematic(litematicFile);
            }

            // Initialize and load
            if (!scene) initThreeJS();
            await loadModel();

        } catch (error) {
            console.error('Error loading shared model:', error);
            alert('Error loading shared model. Please make sure the file is valid.');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('view-only-drop-zone').classList.add('active');
        }
    }

    function generateNameVariants(blockName) {
        const variants = [];
        const lower = blockName.toLowerCase();

        variants.push(lower);
        variants.push(lower.replace(/\s+/g, '_'));

        if (lower.includes('wall banner')) {
            const withoutWall = lower.replace(/\s*wall\s*/g, ' ').trim();
            variants.push(withoutWall);
            variants.push(withoutWall.replace(/\s+/g, '_'));
        }

        if (lower.includes('standing')) {
            const withoutStanding = lower.replace(/\s*standing\s*/g, ' ').trim();
            variants.push(withoutStanding);
            variants.push(withoutStanding.replace(/\s+/g, '_'));
        }

        variants.push(lower.replace(/\s+/g, ''));
        variants.push(lower.replace(/\s+/g, '-'));

        const words = lower.split(/\s+/);
        const singularWords = words.map(w => w.endsWith('s') && w.length > 2 ? w.slice(0, -1) : w);
        variants.push(singularWords.join(' '));
        variants.push(singularWords.join('_'));
        variants.push(singularWords.join(''));
        variants.push(singularWords.join('-'));

        if (words.length > 1) {
            variants.push(words[0]);
            variants.push(words[0].endsWith('s') && words[0].length > 2 ? words[0].slice(0, -1) : words[0]);
        }

        if (words.length > 1) {
            variants.push(words[words.length - 1]);
            const lastWord = words[words.length - 1];
            variants.push(lastWord.endsWith('s') && lastWord.length > 2 ? lastWord.slice(0, -1) : lastWord);
        }

        variants.push(lower.replace('planks', 'plank'));
        variants.push(lower.replace('stairs', 'stair'));
        variants.push(lower.replace('logs', 'log'));
        variants.push(lower.replace('leaves', 'leaf'));

        return [...new Set(variants)];
    }

    function tryLoadIcon(img, blockName, variantIndex = 0) {
        const variants = generateNameVariants(blockName);

        if (variantIndex >= variants.length) {
            img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48"><rect width="48" height="48" fill="%23555"/><text x="24" y="30" text-anchor="middle" fill="white" font-size="20">?</text></svg>';
            img.onerror = null;
            return;
        }

        const variant = variants[variantIndex];
        img.src = `textures/item/${variant}.png`;

        img.onerror = function() {
            tryLoadIcon(img, blockName, variantIndex + 1);
        };

        img.onload = function() {
            img.onerror = null;
            img.onload = null;
        };
    }

    function formatStacks(count) {
        if (count < 64) {
            return count.toString();
        } else if (count === 64) {
            return '1 x 64';
        } else {
            const stacks = Math.floor(count / 64);
            const remainder = count % 64;
            if (remainder === 0) {
                return `${stacks} x 64`;
            } else {
                return `${stacks} x 64 + ${remainder}`;
            }
        }
    }

    function parseNBT(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        function readByte() {
            return view.getInt8(offset++);
        }

        function readShort() {
            const val = view.getInt16(offset);
            offset += 2;
            return val;
        }

        function readInt() {
            const val = view.getInt32(offset);
            offset += 4;
            return val;
        }

        function readLong() {
            const high = view.getInt32(offset);
            const low = view.getInt32(offset + 4);
            offset += 8;
            return (BigInt(high) << 32n) | BigInt(low >>> 0);
        }

        function readString() {
            const length = readShort();
            const bytes = new Uint8Array(buffer, offset, length);
            offset += length;
            return new TextDecoder().decode(bytes);
        }

        function readValue(type) {
            switch (type) {
                case 1: return readByte();
                case 2: return readShort();
                case 3: return readInt();
                case 4: return readLong();
                case 8: return readString();
                case 9: return readList();
                case 10: return readCompound();
                case 11: return readIntArray();
                case 12: return readLongArray();
                default: return null;
            }
        }

        function readList() {
            const type = readByte();
            const length = readInt();
            const list = [];
            for (let i = 0; i < length; i++) {
                list.push(readValue(type));
            }
            return list;
        }

        function readCompound() {
            const compound = {};
            while (true) {
                const type = readByte();
                if (type === 0) break;
                const name = readString();
                compound[name] = readValue(type);
            }
            return compound;
        }

        function readIntArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(readInt());
            }
            return array;
        }

        function readLongArray() {
            const length = readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(readLong());
            }
            return array;
        }

        readByte();
        readString();
        return readCompound();
    }

    function decodeBlockStates(blockStates, bitsPerEntry, totalBlocks) {
        const blockData = [];
        const mask = (1n << BigInt(bitsPerEntry)) - 1n;

        for (let i = 0; i < totalBlocks; i++) {
            const bitPos = i * bitsPerEntry;
            const longIndex = Math.floor(bitPos / 64);
            const bitOffset = bitPos % 64;

            if (longIndex >= blockStates.length) break;

            let entry = blockStates[longIndex];
            let blockId = Number((entry >> BigInt(bitOffset)) & mask);

            if (bitOffset + bitsPerEntry > 64 && longIndex + 1 < blockStates.length) {
                const bitsInNextLong = (bitOffset + bitsPerEntry) - 64;
                const nextEntry = blockStates[longIndex + 1];
                const nextMask = (1n << BigInt(bitsInNextLong)) - 1n;
                const nextPart = Number(nextEntry & nextMask);
                blockId = blockId | (nextPart << (bitsPerEntry - bitsInNextLong));
            }

            blockData.push(blockId);
        }

        return blockData;
    }

    async function parseLitematic(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const decompressed = pako.ungzip(uint8Array);

            const nbt = parseNBT(decompressed.buffer);

            litematicBlocks = [];
            const blockCounts = {};

            if (nbt.Regions) {
                for (const regionName in nbt.Regions) {
                    const region = nbt.Regions[regionName];

                    if (!region.BlockStates || !region.BlockStatePalette || !region.Size) {
                        continue;
                    }

                    const blockStates = region.BlockStates;
                    const palette = region.BlockStatePalette;
                    const size = region.Size;

                    const width = Math.abs(Number(size.x));
                    const height = Math.abs(Number(size.y));
                    const length = Math.abs(Number(size.z));
                    const totalBlocks = width * height * length;

                    const bitsPerEntry = Math.max(2, Math.ceil(Math.log2(palette.length)));
                    const blocks = decodeBlockStates(blockStates, bitsPerEntry, totalBlocks);

                    blocks.forEach(blockId => {
                        if (blockId >= 0 && blockId < palette.length) {
                            const block = palette[blockId];
                            let blockName = block.Name;

                            if (blockName.toLowerCase().includes('air')) return;

                            blockName = blockName.replace('minecraft:', '').replace('potted_', '').replace(/_/g, ' ');
                            blockName = blockName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                            blockName = RENAME_DICT[blockName] || blockName;

                            if (BLOCKS_WITHOUT_TEXTURES.includes(blockName)) {
                                return;
                            }

                            blockCounts[blockName] = (blockCounts[blockName] || 0) + 1;
                        }
                    });
                }
            }

            litematicBlocks = Object.entries(blockCounts)
                .map(([name, count]) => ({ name, count, checked: false }))
                .sort((a, b) => b.count - a.count);

            const saved = localStorage.getItem('blockChecks');
            if (saved) {
                const checks = JSON.parse(saved);
                litematicBlocks.forEach(block => {
                    if (checks[block.name] !== undefined) {
                        block.checked = checks[block.name];
                    }
                });
            }
        } catch (error) {
            console.error('Error parsing litematic:', error);
        }
    }

    function createTextSprite(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'white';
        context.font = 'bold 180px Inter, Arial, sans-serif';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 256, 128);

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(6, 3, 1);
        sprite.renderOrder = 1000;

        return sprite;
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        camera = new THREE.PerspectiveCamera(currentFOV, innerWidth / innerHeight, 0.1, 10000);
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true,
            powerPreference: 'high-performance'
        });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.screenSpacePanning = true;

        controls.addEventListener('start', () => {
            userInteracting = true;
            animating = false;
        });

        controls.addEventListener('end', () => {
            userInteracting = false;
        });

        controls.addEventListener('change', () => {
            cameraMovedSinceLastClick = true;
        });

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        const previewGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const previewMat = new THREE.MeshBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.6,
            depthTest: false
        });
        previewSphere = new THREE.Mesh(previewGeom, previewMat);
        previewSphere.visible = false;
        previewSphere.renderOrder = 999;
        scene.add(previewSphere);

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);

        if (animating && !userInteracting) {
            const deltaY = targetCameraY - camera.position.y;
            const deltaTargetY = targetTargetY - controls.target.y;

            if (Math.abs(deltaY) > 0.01 || Math.abs(deltaTargetY) > 0.01) {
                camera.position.y += deltaY * 0.08;
                controls.target.y += deltaTargetY * 0.08;
            } else {
                camera.position.y = targetCameraY;
                controls.target.y = targetTargetY;
                animating = false;
            }
        }

        if (rulerTextSprite && rulerTextSprite.visible) {
            rulerTextSprite.lookAt(camera.position);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    if (!isViewOnly) {
        document.getElementById('model-input').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                modelZip = e.target.files[0];
                document.getElementById('model-status').textContent = `‚úì ${modelZip.name}`;
                document.getElementById('load-button').style.display = 'inline-flex';
            }
        });

        document.getElementById('litematic-input').addEventListener('change', async (e) => {
            if (e.target.files[0]) {
                litematicFile = e.target.files[0];
                document.getElementById('litematic-status').textContent = `‚úì ${litematicFile.name}`;
                await parseLitematic(litematicFile);
                updateMaterialList();
            }
        });

        document.getElementById('texture-input').addEventListener('change', (e) => {
            customTextures = {};
            Array.from(e.target.files).forEach(file => {
                if (file.type.startsWith('image/')) customTextures[file.name] = URL.createObjectURL(file);
            });
            hasCustomTextures = Object.keys(customTextures).length > 0;
            if (hasCustomTextures) document.getElementById('texture-status').textContent = `‚úì ${Object.keys(customTextures).length} files`;
        });

        document.getElementById('load-button').addEventListener('click', async () => {
            if (!modelZip) {
                alert('Please select a 3D model ZIP file!');
                return;
            }
            document.getElementById('loading').style.display = 'block';
            document.getElementById('main-content').style.display = 'none';
            if (!scene) initThreeJS();
            await loadModel();
        });
    }

    async function loadModel() {
        try {
            const zip = await JSZip.loadAsync(modelZip);
            let objContent = null, mtlContent = null;
            defaultTextures = {};

            for (const [filename, file] of Object.entries(zip.files)) {
                if (file.dir) continue;
                const name = filename.toLowerCase();

                if (name.endsWith('.obj')) {
                    objContent = await file.async('text');
                }
                else if (name.endsWith('.mtl')) {
                    mtlContent = await file.async('text');
                }
                else if (name.match(/\.(png|jpg|jpeg)$/i)) {
                    const texName = filename.split('/').pop().split('\\').pop();
                    defaultTextures[texName] = URL.createObjectURL(await file.async('blob'));
                }
            }

            if (!objContent) { alert('No OBJ file!'); location.reload(); return; }

            if (mtlContent) {
                const lines = mtlContent.split('\n');
                let currentMaterial = null;
                lines.forEach(line => {
                    const t = line.trim();
                    if (t.startsWith('newmtl ')) currentMaterial = t.substring(7).trim();
                    else if (currentMaterial && t.startsWith('map_Kd ')) {
                        textureMap[currentMaterial] = t.substring(7).trim().split('/').pop().split('\\').pop();
                    }
                });
            }

            const manager = new THREE.LoadingManager();
            manager.setURLModifier(url => {
                const fn = url.split('/').pop().split('\\').pop();
                if (defaultTextures[fn]) return defaultTextures[fn];
                for (const [k, v] of Object.entries(defaultTextures)) {
                    if (k.toLowerCase() === fn.toLowerCase()) return v;
                }
                return url;
            });

            const loader = new THREE.OBJLoader(manager);
            if (mtlContent) {
                const mtlLoader = new THREE.MTLLoader(manager);
                const mtls = mtlLoader.parse(mtlContent);
                mtls.preload();
                for (const [, mat] of Object.entries(mtls.materials)) {
                    mat.side = THREE.DoubleSide;
                    if (mat.transparent) {
                        mat.depthWrite = false;
                        mat.alphaTest = 0.1;
                    }
                    if (mat.map) {
                        mat.map.magFilter = THREE.LinearFilter;
                        mat.map.minFilter = THREE.LinearMipMapLinearFilter;
                        mat.map.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                    }
                }
                loader.setMaterials(mtls);
            }

            model = loader.parse(objContent);
            allMeshes = [];
            minY = Infinity; maxY = -Infinity;

            model.traverse(child => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    minY = Math.min(minY, worldPos.y + box.min.y);
                    maxY = Math.max(maxY, worldPos.y + box.max.y);
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.side = THREE.DoubleSide);
                        else child.material.side = THREE.DoubleSide;
                    }
                    child.frustumCulled = true;
                }
            });

            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            modelCenter = center;
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            totalLayers = Math.ceil(maxY - minY);
            layerHeight = (maxY - minY) / totalLayers;

            const distance = maxDim * 1.8;
            const elevationAngle = 60 * (Math.PI / 180);
            const azimuthAngle = 90 * (Math.PI / 180);
            const firstLayerY = minY + layerHeight;
            const cameraY = firstLayerY + distance * Math.sin(elevationAngle);
            const horizontalDist = distance * Math.cos(elevationAngle);
            const cameraX = center.x + horizontalDist * Math.cos(azimuthAngle);
            const cameraZ = center.z + horizontalDist * Math.sin(azimuthAngle);

            initialCameraX = cameraX; initialCameraY = cameraY; initialCameraZ = cameraZ;

            camera.position.set(cameraX, cameraY, cameraZ);
            controls.target.set(center.x, firstLayerY, center.z);
            targetCameraY = cameraY;
            targetTargetY = firstLayerY;

            const slider = document.getElementById('layer-slider');
            slider.min = 1; slider.max = totalLayers; slider.value = 1;
            currentLayer = 1; previousLayer = 1;

            updateLayerDisplay();
            updateVisibility();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                document.getElementById('toggle-texture').disabled = false;
                document.getElementById('toggle-texture').classList.add('active');
            }

            if (litematicBlocks.length > 0) {
                updateMaterialList();
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('viewer-container').style.display = 'block';
            document.getElementById('layer-info-top').style.display = 'block';
            document.getElementById('arrow-left').style.display = 'flex';
            document.getElementById('arrow-right').style.display = 'flex';
            document.getElementById('material-toggle').style.display = 'flex';
            document.getElementById('right-controls').style.display = 'flex';
            document.getElementById('layer-slider-container').style.display = 'block';

            // Hide share button in view-only mode
            if (isViewOnly) {
                document.getElementById('share-button').style.display = 'none';
            }
        } catch (error) {
            alert('Error: ' + error.message);
            console.error(error);
            location.reload();
        }
    }

    function updateMaterialList() {
        const list = document.getElementById('material-list');
        list.innerHTML = '';

        if (litematicBlocks.length > 0) {
            litematicBlocks.forEach((block) => {
                const item = document.createElement('div');
                item.className = 'material-item' + (block.checked ? ' checked' : '');

                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'material-checkbox-container';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'material-checkbox';
                checkbox.checked = block.checked;
                checkbox.addEventListener('change', (e) => {
                    block.checked = e.target.checked;
                    item.classList.toggle('checked', e.target.checked);
                    saveCheckboxes();
                });
                checkboxContainer.appendChild(checkbox);

                const imgContainer = document.createElement('div');
                imgContainer.className = 'material-img-container';
                const img = document.createElement('img');
                img.className = 'material-img';

                tryLoadIcon(img, block.name);

                imgContainer.appendChild(img);

                const nameDiv = document.createElement('div');
                nameDiv.className = 'material-name';
                nameDiv.textContent = block.name;

                const quantityDiv = document.createElement('div');
                quantityDiv.className = 'material-quantity';
                quantityDiv.textContent = block.count.toString();

                const stacksDiv = document.createElement('div');
                stacksDiv.className = 'material-stacks';
                stacksDiv.textContent = formatStacks(block.count);

                item.appendChild(checkboxContainer);
                item.appendChild(imgContainer);
                item.appendChild(nameDiv);
                item.appendChild(quantityDiv);
                item.appendChild(stacksDiv);

                list.appendChild(item);
            });
        } else {
            list.innerHTML = '<p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load litematic</p>';
        }
    }

    function saveCheckboxes() {
        const checks = {};
        litematicBlocks.forEach(block => {
            checks[block.name] = block.checked;
        });
        localStorage.setItem('blockChecks', JSON.stringify(checks));
    }

    function applyTextures() {
        const currentTextures = isCustomMode ? customTextures : defaultTextures;
        allMeshes.forEach(mesh => {
            if (!mesh.material) return;
            const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
            mats.forEach(mat => {
                if (!mat.name) return;
                const texName = textureMap[mat.name];
                if (!texName) return;
                const cleanTexName = texName.split('/').pop().split('\\').pop();
                if (currentTextures[cleanTexName]) {
                    const texture = new THREE.TextureLoader().load(currentTextures[cleanTexName]);
                    texture.magFilter = THREE.LinearFilter;
                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                    mat.map = texture;
                    mat.needsUpdate = true;
                    return;
                }
            });
        });
    }

    function snapToBlockEdge(point) {
        return new THREE.Vector3(
            Math.round(point.x),
            Math.round(point.y),
            Math.round(point.z)
        );
    }

    function getStraightLine(p1, p2) {
        const dx = Math.abs(p2.x - p1.x);
        const dy = Math.abs(p2.y - p1.y);
        const dz = Math.abs(p2.z - p1.z);

        if (dx >= dy && dx >= dz) {
            return new THREE.Vector3(p2.x, p1.y, p1.z);
        } else if (dy >= dx && dy >= dz) {
            return new THREE.Vector3(p1.x, p2.y, p1.z);
        } else {
            return new THREE.Vector3(p1.x, p1.y, p2.z);
        }
    }

    function manhattanDistance(p1, p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) + Math.abs(p1.z - p2.z);
    }

    document.getElementById('ruler-toggle').addEventListener('click', () => {
        rulerActive = !rulerActive;
        const btn = document.getElementById('ruler-toggle');
        if (rulerActive) {
            btn.classList.add('active');
            clearRuler();
        } else {
            btn.classList.remove('active');
            clearRuler();
            previewSphere.visible = false;
        }
    });

    function clearRuler() {
        rulerPoints = [];
        if (rulerLine) {
            scene.remove(rulerLine);
            rulerLine = null;
        }
        if (rulerTextSprite) {
            scene.remove(rulerTextSprite);
            rulerTextSprite = null;
        }
        rulerSpheres.forEach(sphere => scene.remove(sphere));
        rulerSpheres = [];
    }

    document.addEventListener('mousemove', (event) => {
        if (!renderer || !renderer.domElement) return;

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (rulerActive && rulerPoints.length < 2) {
            if (intersects.length > 0) {
                const rawPoint = intersects[0].point;
                const snappedPoint = snapToBlockEdge(rawPoint);

                if (rulerPoints.length === 1) {
                    const straightPoint = getStraightLine(rulerPoints[0], snappedPoint);
                    previewSphere.position.copy(straightPoint);
                } else {
                    previewSphere.position.copy(snappedPoint);
                }
                previewSphere.visible = true;
            } else {
                previewSphere.visible = false;
            }
        }
    });

    document.addEventListener('click', (event) => {
        if (!rulerActive || !renderer || !renderer.domElement) return;

        if (rulerPoints.length >= 2) {
            if (!cameraMovedSinceLastClick) {
                clearRuler();
                previewSphere.visible = false;
            }
            cameraMovedSinceLastClick = false;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (intersects.length > 0) {
            const rawPoint = intersects[0].point;
            const snappedPoint = snapToBlockEdge(rawPoint);

            let finalPoint = snappedPoint;

            if (rulerPoints.length === 1) {
                finalPoint = getStraightLine(rulerPoints[0], snappedPoint);
            }

            rulerPoints.push(finalPoint);

            const sphereGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            sphere.position.copy(finalPoint);
            sphere.renderOrder = 999;
            scene.add(sphere);
            rulerSpheres.push(sphere);

            if (rulerPoints.length === 2) {
                previewSphere.visible = false;

                const lineGeom = new THREE.BufferGeometry().setFromPoints(rulerPoints);
                const lineMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 2,
                    depthTest: false
                });
                rulerLine = new THREE.Line(lineGeom, lineMat);
                rulerLine.renderOrder = 998;
                scene.add(rulerLine);

                const distance = manhattanDistance(rulerPoints[0], rulerPoints[1]);

                const midPoint = new THREE.Vector3().addVectors(rulerPoints[0], rulerPoints[1]).multiplyScalar(0.5);
                rulerTextSprite = createTextSprite(distance.toString());
                rulerTextSprite.position.copy(midPoint);
                rulerTextSprite.position.y += 2;
                scene.add(rulerTextSprite);

                cameraMovedSinceLastClick = false;
            }
        }
    });

    document.getElementById('toggle-texture').addEventListener('click', () => {
        if (!hasCustomTextures) return;
        isCustomMode = !isCustomMode;
        const btn = document.getElementById('toggle-texture');
        isCustomMode ? btn.classList.add('active') : btn.classList.remove('active');
        applyTextures();
    });

    document.getElementById('material-toggle').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.toggle('active');
    });

    document.getElementById('close-modal').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.remove('active');
    });

    document.getElementById('material-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'material-modal-overlay') {
            document.getElementById('material-modal-overlay').classList.remove('active');
        }
    });

    document.getElementById('fov-toggle').addEventListener('click', () => {
        currentFOV = currentFOV === 40 ? 60 : 40;
        camera.fov = currentFOV;
        camera.updateProjectionMatrix();
        const btn = document.getElementById('fov-toggle');
        btn.classList.toggle('active');
    });

    function updateCameraHeight() {
        const layerDifference = currentLayer - previousLayer;
        const yShift = layerDifference * layerHeight;
        targetCameraY = camera.position.y + yShift;
        targetTargetY = controls.target.y + yShift;
        previousLayer = currentLayer;
        animating = true;
    }

    function updateVisibility() {
        const currentMaxY = minY + currentLayer;
        allMeshes.forEach(mesh => {
            const worldPos = new THREE.Vector3();
            mesh.getWorldPosition(worldPos);
            mesh.visible = (worldPos.y + mesh.geometry.boundingBox.max.y) <= currentMaxY + 0.1;
        });
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = `Layer ${currentLayer} / ${totalLayers}`;
    }

    document.getElementById('layer-slider').addEventListener('input', (e) => {
        currentLayer = parseInt(e.target.value);
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (model) {
            const currentLayerY = minY + (currentLayer * layerHeight);
            const firstLayerY = minY + layerHeight;
            const yOffset = currentLayerY - firstLayerY;
            camera.position.set(initialCameraX, initialCameraY + yOffset, initialCameraZ);
            controls.target.set(modelCenter.x, firstLayerY + yOffset, modelCenter.z);
            targetCameraY = initialCameraY + yOffset;
            targetTargetY = firstLayerY + yOffset;
            animating = false;
            userInteracting = false;
        }
    });

    addEventListener('resize', () => {
        if (camera && renderer) {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
    });
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Minecraft Layer Viewer</title>
    
    <link rel="icon" type="image/png" href="/skin-avatar.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Inter', sans-serif; background: #1a1a1a; color: #fff; overflow: hidden; height: 100vh; touch-action: none; }

        @keyframes wave {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-15deg); }
        }

        #main-content { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; text-align: center; padding: 20px; }
        .upload-container { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 2px dashed rgba(255,255,255,0.2); border-radius: 20px; padding: 40px; max-width: 900px; width: 95%; }
        h1 { font-size: 28px; font-weight: 700; margin-bottom: 10px; }
        .subtitle { font-size: 14px; color: rgba(255,255,255,0.5); margin-bottom: 30px; }

        .upload-section { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; }
        .upload-box { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; border: 2px solid rgba(255,255,255,0.1); transition: all 0.3s; }
        .upload-box:hover { border-color: rgba(102,126,234,0.5); background: rgba(102,126,234,0.1); }
        .upload-box h3 { font-size: 14px; margin-bottom: 8px; color: #667eea; font-weight: 600; }
        .file-status { font-size: 11px; color: #4ade80; margin-top: 10px; min-height: 16px; font-weight: 500; }
        input[type="file"] { display: none; }
        .upload-button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 25px; border-radius: 50px; font-size: 13px; font-weight: 600; border: none; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s; }
        .upload-button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102,126,234,0.5); }
        
        .camera-settings {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            margin-bottom: 20px;
        }
        
        .camera-settings h3 {
            font-size: 14px;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .camera-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .camera-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .camera-control label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .camera-control-value {
            font-weight: 600;
            color: #4ade80;
        }
        
        .camera-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        .camera-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .camera-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .load-button { background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%); color: white; padding: 16px 45px; border-radius: 50px; font-size: 16px; font-weight: 600; border: none; cursor: pointer; display: none; margin: 0 auto; transition: all 0.3s; }
        .load-button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(74,222,128,0.5); }

        #viewer-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; background: #2a2a2a; }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 3000; display: none; background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; }
        .spinner { border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid #667eea; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .disclaimer-notification {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: rgba(30, 30, 35, 0.98);
            border-radius: 12px;
            max-width: 400px;
            width: calc(100% - 60px);
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            z-index: 5000;
            display: none;
            animation: slideInLeft 0.4s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .disclaimer-notification.active {
            display: block;
        }

        .disclaimer-notification-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .disclaimer-notification-icon {
            font-size: 20px;
            color: #fbbf24;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .disclaimer-notification-title {
            font-size: 16px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            flex: 1;
        }

        .disclaimer-notification-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 24px;
            line-height: 1;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .disclaimer-notification-close:hover {
            color: rgba(255,255,255,0.9);
        }

        .disclaimer-notification-content {
            color: rgba(255,255,255,0.75);
            font-size: 13px;
            line-height: 1.6;
            padding-left: 32px;
        }

        .layer-info-top { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 40px; border-radius: 15px; font-size: 20px; font-weight: 600; z-index: 1000; display: none; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1); }

        .arrow-button { position: fixed; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.2); color: white; width: 80px; height: 80px; border-radius: 50%; cursor: pointer; display: none; align-items: center; justify-content: center; z-index: 1000; transition: all 0.3s; backdrop-filter: blur(10px); }
        .arrow-button:hover { background: rgba(102,126,234,0.8); transform: translateY(-50%) scale(1.1); }
        .arrow-button:active { transform: translateY(-50%) scale(0.95); }
        .arrow-left { left: 30px; }
        .arrow-right { right: 30px; }
        .arrow-button .material-icons { font-size: 60px; }

        .material-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .material-modal-overlay.active { display: flex; }

        .material-modal {
            background: rgba(30, 30, 35, 0.98);
            border-radius: 15px;
            width: 90%;
            max-width: 680px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .material-header { padding: 20px 25px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; }
        .material-header h2 { font-size: 20px; font-weight: 600; color: rgba(255,255,255,0.95); }
        .close-modal { background: none; border: none; color: white; cursor: pointer; font-size: 32px; line-height: 1; opacity: 0.7; transition: opacity 0.2s; padding: 0; }
        .close-modal:hover { opacity: 1; }
        .close-modal:active { transform: scale(0.9); }

        .material-table-header {
            display: grid;
            grid-template-columns: 55px 60px 1fr 110px 130px;
            gap: 15px;
            padding: 14px 25px;
            background: rgba(40, 40, 45, 0.6);
            border-bottom: 2px solid rgba(255,255,255,0.15);
            font-size: 14px;
            font-weight: 700;
            color: rgba(255,255,255,0.85);
            align-items: center;
        }

        .material-table-header > div {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .material-table-header > div:nth-child(3) {
            justify-content: flex-start;
            padding-left: 5px;
        }

        .material-list { overflow-y: auto; max-height: calc(85vh - 140px); }
        .material-item {
            display: grid;
            grid-template-columns: 55px 60px 1fr 110px 130px;
            gap: 15px;
            align-items: center;
            padding: 12px 25px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s;
        }
        .material-item:hover { background: rgba(255,255,255,0.04); }
        .material-item.checked { opacity: 0.4; }

        .material-checkbox-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .material-checkbox {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: #4ade80;
        }

        .material-img-container {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .material-name {
            font-size: 15px;
            font-weight: 500;
            color: rgba(255,255,255,0.95);
            text-align: left;
            padding-left: 5px;
            display: flex;
            align-items: center;
        }
        .material-item.checked .material-name { text-decoration: line-through; color: rgba(255,255,255,0.4); }

        .material-quantity {
            font-size: 15px;
            color: rgba(255,255,255,0.9);
            text-align: center;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-item.checked .material-quantity { text-decoration: line-through; color: rgba(255,255,255,0.35); }

        .material-stacks {
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .material-item.checked .material-stacks { text-decoration: line-through; color: rgba(255,255,255,0.35); }

        .material-toggle { 
            position: fixed; 
            left: 30px; 
            top: 30px; 
            background: rgba(0,0,0,0.7); 
            border: 2px solid rgba(255,255,255,0.1); 
            color: white; 
            width: 70px; 
            height: 70px; 
            border-radius: 15px; 
            cursor: pointer; 
            display: none; 
            align-items: center; 
            justify-content: center; 
            z-index: 1500; 
            backdrop-filter: blur(10px); 
            transition: all 0.3s; 
        }
        .material-toggle .material-icons { 
            font-size: 36px; 
        }
        .material-toggle:hover { background: rgba(102,126,234,0.8); transform: scale(1.1); }
        .material-toggle:active { transform: scale(0.95); }

        .right-controls { position: fixed; top: 30px; right: 30px; display: none; flex-direction: column; gap: 15px; z-index: 1000; }
        .icon-button { background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.1); color: white; width: 60px; height: 60px; border-radius: 15px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s; }
        .icon-button:hover { background: rgba(102,126,234,0.8); transform: scale(1.1); }
        .icon-button:active { transform: scale(0.95); }
        .icon-button.active { background: rgba(74,222,128,0.8); border-color: rgba(74,222,128,0.5); }
        .icon-button:disabled { opacity: 0.3; cursor: not-allowed; }

        .layer-slider-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 20px 40px; border-radius: 50px; display: none; z-index: 1000; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1); }
        .layer-slider { width: 400px; height: 8px; border-radius: 4px; background: rgba(255,255,255,0.2); outline: none; -webkit-appearance: none; }
        .layer-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; border-radius: 50%; background: #667eea; cursor: pointer; }
        .layer-slider::-moz-range-thumb { width: 24px; height: 24px; border-radius: 50%; background: #667eea; cursor: pointer; border: none; }

        @media (max-width: 1024px) {
            .upload-section { grid-template-columns: 1fr; gap: 10px; }
            .upload-container { padding: 30px 20px; }
            h1 { font-size: 24px; }
            .subtitle { font-size: 13px; }
            .camera-controls { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            body { font-size: 14px; }
            
            .upload-section { grid-template-columns: 1fr; }
            .upload-container { padding: 25px 15px; }
            h1 { font-size: 22px; }
            .subtitle { font-size: 12px; }
            .upload-box { padding: 15px; }
            .upload-box h3 { font-size: 13px; }
            
            .camera-settings { padding: 15px; }
            .camera-controls { grid-template-columns: 1fr; gap: 12px; }
            
            .disclaimer-notification {
                bottom: 15px;
                left: 15px;
                max-width: calc(100% - 30px);
                padding: 16px;
            }

            .disclaimer-notification-title {
                font-size: 15px;
            }

            .disclaimer-notification-content {
                font-size: 12px;
                padding-left: 32px;
            }
            
            .layer-slider-container { 
                bottom: 20px; 
                padding: 12px 30px;
                border-radius: 30px;
                background: rgba(0,0,0,0.85);
            }
            
            .layer-slider { 
                width: 60vw; 
                height: 6px;
            }
            .layer-slider::-webkit-slider-thumb { width: 28px; height: 28px; }
            .layer-slider::-moz-range-thumb { width: 28px; height: 28px; }
            
            .arrow-button { 
                width: 65px; 
                height: 65px; 
                border-width: 2px;
            }
            .arrow-button .material-icons { font-size: 40px; }
            .arrow-left { left: 15px; }
            .arrow-right { right: 15px; }
            
            .icon-button { 
                width: 50px; 
                height: 50px;
                border-width: 2px;
            }
            .icon-button .material-icons { font-size: 26px; }
            
            .material-toggle { 
                width: 60px; 
                height: 60px; 
                left: 15px;
                top: 15px;
            }
            .material-toggle .material-icons { 
                font-size: 32px; 
            }
            
            .right-controls { 
                top: 15px; 
                right: 15px; 
                gap: 10px; 
            }
            
            .layer-info-top { 
                font-size: 16px; 
                padding: 10px 20px;
                top: 15px;
            }
            
            .material-modal { 
                width: 100%; 
                height: 100%;
                max-width: none;
                max-height: 100vh;
                margin: 0;
                border-radius: 0;
            }
            
            .material-header { 
                padding: 15px 15px; 
                position: sticky;
                top: 0;
                background: rgba(30, 30, 35, 1);
                z-index: 10;
            }
            .material-header h2 { font-size: 18px; }
            .close-modal { font-size: 32px; padding: 5px 10px; }
            
            .material-table-header {
                position: sticky;
                top: 59px;
                z-index: 9;
                background: rgba(30, 30, 35, 1);
                grid-template-columns: 40px 45px 1fr 75px;
                gap: 5px; 
                font-size: 11px; 
                padding: 10px 8px;
            }
            
            .material-table-header > div:nth-child(5) {
                display: none;
            }
            
            .material-list { 
                max-height: none;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .material-item { 
                grid-template-columns: 40px 45px 1fr 75px;
                gap: 5px; 
                font-size: 12px; 
                padding: 10px 8px;
            }
            
            .material-item > div:nth-child(5) {
                display: none;
            }
            
            .material-name { font-size: 13px; word-break: break-word; }
            .material-quantity { font-size: 13px; }
            
            .material-checkbox { width: 20px; height: 20px; }
            
            .material-img-container { width: 38px; height: 38px; }
            .material-img { width: 32px; height: 32px; }
            
            .loading { padding: 30px 25px; }
            .spinner { width: 50px; height: 50px; }
            .loading p { font-size: 14px; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 20px; }
            .subtitle { font-size: 11px; }
            
            .disclaimer-notification {
                bottom: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
                padding: 14px;
            }
            
            .layer-slider-container {
                bottom: 15px;
                padding: 10px 25px;
            }
            
            .layer-slider { width: 55vw; }
            
            .arrow-button { 
                width: 55px; 
                height: 55px; 
            }
            .arrow-button .material-icons { font-size: 34px; }
            .arrow-left { left: 10px; }
            .arrow-right { right: 10px; }
            
            .icon-button { 
                width: 45px; 
                height: 45px; 
            }
            .icon-button .material-icons { font-size: 22px; }
            
            .material-toggle { 
                width: 55px; 
                height: 55px; 
                left: 10px;
                top: 10px;
            }
            .material-toggle .material-icons { 
                font-size: 28px; 
            }
            
            .right-controls { 
                top: 10px; 
                right: 10px; 
                gap: 8px; 
            }
            
            .layer-info-top { 
                font-size: 15px; 
                padding: 8px 18px;
                top: 10px;
            }
            
            .material-table-header, .material-item { 
                grid-template-columns: 35px 40px 1fr 70px;
                gap: 4px; 
                font-size: 11px; 
                padding: 8px 6px;
            }
            
            .material-name { font-size: 12px; }
            .material-quantity { font-size: 12px; }
            
            .material-checkbox { width: 18px; height: 18px; }
            
            .material-img-container { width: 35px; height: 35px; }
            .material-img { width: 28px; height: 28px; }
        }

        @media (max-width: 900px) and (orientation: landscape) {
            .layer-info-top { 
                top: 5px;
                font-size: 13px;
                padding: 6px 12px;
            }
            
            .arrow-button { 
                width: 50px; 
                height: 50px; 
                top: 50%;
            }
            .arrow-button .material-icons { font-size: 32px; }
            .arrow-left { left: 8px; }
            .arrow-right { right: 8px; }
            
            .icon-button { 
                width: 42px; 
                height: 42px; 
            }
            .icon-button .material-icons { font-size: 22px; }
            
            .material-toggle { 
                width: 45px; 
                height: 45px; 
                left: 8px;
                bottom: 60px;
                top: auto;
            }
            .material-toggle .material-icons { 
                font-size: 24px; 
            }
            
            .right-controls { 
                top: 5px;
                right: 8px;
                gap: 6px;
                flex-direction: row;
            }
            
            .layer-slider-container { 
                bottom: 5px;
                padding: 8px 20px;
            }
            
            .layer-slider { 
                height: 6px; 
                width: 50vw; 
            }
            .layer-slider::-webkit-slider-thumb { width: 24px; height: 24px; }
            .layer-slider::-moz-range-thumb { width: 24px; height: 24px; }
            
            .disclaimer-notification {
                bottom: 60px;
                left: 8px;
                max-width: 350px;
            }
            
            .material-modal {
                width: 100%;
                height: 100%;
                max-height: 100vh;
            }
            
            .material-table-header {
                grid-template-columns: 35px 40px 1fr 70px 95px;
                gap: 6px;
                font-size: 11px;
                padding: 8px 10px;
            }
            
            .material-table-header > div:nth-child(5) {
                display: flex !important;
            }
            
            .material-item {
                grid-template-columns: 35px 40px 1fr 70px 95px;
                gap: 6px;
                font-size: 11px;
                padding: 8px 10px;
            }
            
            .material-item > div:nth-child(5) {
                display: flex !important;
            }
            
            .material-name { font-size: 12px; }
            .material-quantity { font-size: 12px; }
            .material-stacks { font-size: 11px; }
            
            .material-checkbox { width: 18px; height: 18px; }
            
            .material-img-container { width: 35px; height: 35px; }
            .material-img { width: 30px; height: 30px; }
        }

        @media (max-width: 700px) and (max-height: 400px) and (orientation: landscape) {
            .layer-info-top { 
                top: 3px;
                font-size: 12px;
                padding: 5px 10px;
            }
            
            .arrow-button { 
                width: 45px; 
                height: 45px; 
            }
            .arrow-button .material-icons { font-size: 28px; }
            .arrow-left { left: 5px; }
            .arrow-right { right: 5px; }
            
            .icon-button { 
                width: 38px; 
                height: 38px; 
            }
            .icon-button .material-icons { font-size: 20px; }
            
            .material-toggle { 
                width: 40px; 
                height: 40px; 
                left: 5px;
                bottom: 50px;
            }
            .material-toggle .material-icons { 
                font-size: 22px; 
            }
            
            .right-controls { 
                gap: 5px; 
                top: 3px;
                right: 5px;
            }
            
            .layer-slider-container { 
                bottom: 3px;
                padding: 6px 15px;
            }
            
            .layer-slider { height: 5px; width: 45vw; }
            .layer-slider::-webkit-slider-thumb { width: 22px; height: 22px; }
            .layer-slider::-moz-range-thumb { width: 22px; height: 22px; }
            
            .disclaimer-notification {
                bottom: 50px;
                left: 5px;
                max-width: 300px;
                padding: 12px;
            }
            
            .material-table-header, .material-item {
                grid-template-columns: 30px 35px 1fr 60px 85px;
                gap: 4px;
                font-size: 10px;
                padding: 6px 6px;
            }
            
            .material-name { font-size: 11px; }
            .material-quantity { font-size: 11px; }
            .material-stacks { font-size: 10px; }
            
            .material-img-container { width: 30px; height: 30px; }
            .material-img { width: 26px; height: 26px; }
        }
    </style>
</head>
<body>

<div id="welcome-message" style="display: none;">
    <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
        <div style="text-align: center; max-width: 700px; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 60px 40px; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
            <span id="secret-emoji" style="font-size: 80px; margin-bottom: 30px; display: block; animation: wave 2s ease-in-out infinite; cursor: pointer;">üëã</span>
            <h1 style="font-size: 42px; font-weight: 700; margin-bottom: 20px; text-shadow: 0 2px 10px rgba(0,0,0,0.2);">Hello there!</h1>
            <p style="font-size: 18px; opacity: 0.95; line-height: 1.8; margin-bottom: 15px;">This is a <span style="font-weight: 600; color: #ffd700;">private workspace</span> for Sereyka's projects.</p>
            <p style="font-size: 18px; opacity: 0.95; line-height: 1.8; margin-bottom: 15px;">If you received a link to view a specific model, please use that direct link instead.</p>
            <p style="margin-top: 30px; font-size: 16px; opacity: 0.8;">Have a great day! üòä</p>
        </div>
    </div>
</div>

<div id="main-content" style="display: none;">
    <div class="upload-container">
        <h1>Viewer</h1>
        <p class="subtitle">Load files</p>

        <div class="upload-section">
            <div class="upload-box">
                <h3>File 1</h3>
                <input type="file" id="model-input" accept=".zip">
                <label for="model-input" class="upload-button">
                    <span class="material-icons">upload_file</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="model-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 2</h3>
                <input type="file" id="litematic-input" accept=".litematic,.schem,.schematic">
                <label for="litematic-input" class="upload-button">
                    <span class="material-icons">account_tree</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="litematic-status"></div>
            </div>

            <div class="upload-box">
                <h3>File 3</h3>
                <input type="file" id="texture-input" accept=".png,.jpg,.jpeg" multiple>
                <label for="texture-input" class="upload-button">
                    <span class="material-icons">collections</span>
                    <span>Select</span>
                </label>
                <div class="file-status" id="texture-status"></div>
            </div>
        </div>

        <div class="camera-settings">
            <h3>Camera Settings</h3>
            <div class="camera-controls">
                <div class="camera-control">
                    <label>
                        <span>Rotation</span>
                        <span class="camera-control-value" id="rotation-value">90¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="rotation-slider" min="0" max="360" value="90">
                </div>
                <div class="camera-control">
                    <label>
                        <span>Tilt</span>
                        <span class="camera-control-value" id="tilt-value">60¬∞</span>
                    </label>
                    <input type="range" class="camera-slider" id="tilt-slider" min="0" max="90" value="60">
                </div>
            </div>
        </div>

        <button class="load-button" id="load-button">
            <span class="material-icons">play_arrow</span>
            <span>Load</span>
        </button>
    </div>
</div>

<div class="disclaimer-notification" id="disclaimer-notification">
    <div class="disclaimer-notification-header">
        <span class="disclaimer-notification-icon">‚ö†Ô∏è</span>
        <span class="disclaimer-notification-title">Please note</span>
        <button class="disclaimer-notification-close" id="disclaimer-close">√ó</button>
    </div>
    <div class="disclaimer-notification-content">
        This 3D guide is not a reproduction of the Minecraft¬Æ game. It is an original and independent creation designed to assist players and enhance their building experience. Sereyka Layer Viewer is not affiliated with, endorsed, authorized, or sponsored by Mojang Studios, Microsoft, or any of their affiliates. All rights to Minecraft¬Æ and related assets are owned by Mojang Studios and Microsoft.
    </div>
</div>

<div id="viewer-container"></div>
<div class="loading" id="loading"><div class="spinner"></div><p>Loading...</p></div>

<div class="layer-info-top" id="layer-info-top">Layer 1 / 38</div>

<button class="arrow-button arrow-left" id="arrow-left"><span class="material-icons">chevron_left</span></button>
<button class="arrow-button arrow-right" id="arrow-right"><span class="material-icons">chevron_right</span></button>

<div class="material-modal-overlay" id="material-modal-overlay">
    <div class="material-modal">
        <div class="material-header">
            <h2>‚úÖ Materials List</h2>
            <button class="close-modal" id="close-modal">√ó</button>
        </div>
        <div class="material-table-header">
            <div>‚úÖ</div>
            <div>üñºÔ∏è</div>
            <div>Block</div>
            <div>Quantity</div>
            <div>Stacks</div>
        </div>
        <div class="material-list" id="material-list">
            <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px 20px;">Load a litematic file</p>
        </div>
    </div>
</div>

<button class="material-toggle" id="material-toggle" title="Material List"><span class="material-icons">inventory_2</span></button>

<div class="right-controls" id="right-controls">
    <button class="icon-button" id="share-button" title="Share Model"><span class="material-icons">share</span></button>
    <button class="icon-button" id="ruler-toggle" title="Ruler"><span class="material-icons">straighten</span></button>
    <button class="icon-button" id="fov-toggle" title="FOV"><span class="material-icons">photo_camera</span></button>
    <button class="icon-button" id="reset-camera" title="Camera Reset"><span class="material-icons">cameraswitch</span></button>
    <button class="icon-button" id="toggle-texture" title="Outline" disabled><span class="material-icons">texture</span></button>
</div>

<div class="layer-slider-container" id="layer-slider-container">
    <input type="range" class="layer-slider" id="layer-slider" min="1" max="100" value="1">
</div>

<script>
    // ============================================
    // üöÄ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨–Æ
    // ============================================
    
    'use strict';
    
    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let scene, camera, renderer, controls;
    let model, allMeshes = [], currentLayer = 1, previousLayer = 1, minY = 0, maxY = 0, totalLayers = 0;
    let modelZip = null, litematicFile = null, defaultTextures = {}, customTextures = {}, textureMap = {}, isCustomMode = false, hasCustomTextures = false;
    let initialCameraX, initialCameraY, initialCameraZ, modelCenter, layerHeight;
    let targetCameraY = 0, targetTargetY = 0, animating = false, userInteracting = false;
    let currentFOV = 40;
    let litematicBlocks = [];

    // Ruler
    let rulerActive = false, rulerPoints = [], rulerLine = null, rulerSpheres = [], previewSphere = null, rulerTextSprite = null;
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), cameraMovedSinceLastClick = false;

    // Camera settings
    let cameraRotation = 90, cameraTilt = 60;

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ö—ç—à –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
    const vectorPool = {
        vectors: [],
        get() {
            return this.vectors.pop() || new THREE.Vector3();
        },
        release(v) {
            v.set(0, 0, 0);
            this.vectors.push(v);
        }
    };

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    const TRANSPARENT_MATERIALS = ['glass', 'pane', 'potted', 'stained_glass'];
    const RENAME_DICT = {
        "Beetroots": "Beetroot",
        "Potatoes": "Potato",
        "Carrots": "Carrot",
        "Wheat Crops": "Wheat",
        "Water Cauldron": "Cauldron"
    };
    const BLOCKS_WITHOUT_TEXTURES = ["Nether Portal", "End Portal", "End Gateway"];

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ (–∫—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã)
    const transparencyCache = new Map();
    function shouldBeTransparent(materialName) {
        if (!materialName) return false;
        if (transparencyCache.has(materialName)) return transparencyCache.get(materialName);
        const nameLower = materialName.toLowerCase();
        const result = TRANSPARENT_MATERIALS.some(keyword => nameLower.includes(keyword));
        transparencyCache.set(materialName, result);
        return result;
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    document.getElementById('rotation-slider').addEventListener('input', (e) => {
        cameraRotation = parseInt(e.target.value);
        document.getElementById('rotation-value').textContent = cameraRotation + '¬∞';
    });

    document.getElementById('tilt-slider').addEventListener('input', (e) => {
        cameraTilt = parseInt(e.target.value);
        document.getElementById('tilt-value').textContent = cameraTilt + '¬∞';
    });

    function showDisclaimer() {
        document.getElementById('disclaimer-notification').classList.add('active');
    }

    document.getElementById('disclaimer-close').addEventListener('click', () => {
        document.getElementById('disclaimer-notification').classList.remove('active');
    });

    // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–Ω–æ–ø–∫–∞
    let clickCount = 0, clickTimer = null;

    window.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const viewFile = urlParams.get('view');
        const adminMode = urlParams.has('admin');
        
        const emoji = document.getElementById('secret-emoji');
        if (emoji) {
            emoji.addEventListener('click', () => {
                clickCount++;
                if (clickCount === 1) {
                    clickTimer = setTimeout(() => clickCount = 0, 1000);
                }
                if (clickCount === 3) {
                    clearTimeout(clickTimer);
                    clickCount = 0;
                    document.getElementById('welcome-message').style.display = 'none';
                    document.getElementById('main-content').style.display = 'flex';
                }
            });
        }
        
        if (viewFile) {
            console.log('üîó View mode:', viewFile);
            document.getElementById('main-content').style.display = 'none';
            document.getElementById('welcome-message').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            
            fetch('./shared/' + viewFile + '.mcviewer')
                .then(response => {
                    if (!response.ok) throw new Error('File not found');
                    return response.blob();
                })
                .then(async blob => {
                    await loadSharedModel(new File([blob], viewFile + '.mcviewer'));
                    setTimeout(showDisclaimer, 500);
                    setTimeout(() => {
                        const shareBtn = document.getElementById('share-button');
                        if (shareBtn) shareBtn.style.display = 'none';
                    }, 1000);
                })
                .catch(error => {
                    console.error('‚ùå Load error:', error);
                    alert('‚ùå Model not found');
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-content').style.display = 'flex';
                });
        }
        else if (adminMode) {
            document.getElementById('welcome-message').style.display = 'none';
            document.getElementById('main-content').style.display = 'flex';
        }
        else {
            document.getElementById('main-content').style.display = 'none';
            document.getElementById('welcome-message').style.display = 'block';
        }
    });

    async function loadSharedModel(file) {
        document.getElementById('loading').style.display = 'block';
        try {
            const zip = await JSZip.loadAsync(file);
            const modelFile = await zip.file('model.zip').async('blob');
            modelZip = new File([modelFile], 'model.zip');

            const litematicZipFile = zip.file('litematic.litematic');
            if (litematicZipFile) {
                litematicFile = new File([await litematicZipFile.async('blob')], 'litematic.litematic');
                await parseLitematic(litematicFile);
            }

            const customTexturesFolder = zip.folder('custom_textures');
            if (customTexturesFolder) {
                customTextures = {};
                const files = [];
                customTexturesFolder.forEach((relativePath, file) => {
                    if (!file.dir) files.push(file);
                });
                
                console.log('üì¶ Loading', files.length, 'textures');
                for (const file of files) {
                    const fileName = file.name.split('/').pop();
                    customTextures[fileName] = URL.createObjectURL(await file.async('blob'));
                }
                
                if (Object.keys(customTextures).length > 0) {
                    hasCustomTextures = true;
                    console.log('üé® Textures loaded:', Object.keys(customTextures).length);
                }
            }

            if (!scene) initThreeJS();
            await loadModel();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                const toggleBtn = document.getElementById('toggle-texture');
                if (toggleBtn) {
                    toggleBtn.disabled = false;
                    toggleBtn.classList.add('active');
                }
            }
        } catch (error) {
            console.error('Error loading model:', error);
            alert('Error loading model');
            document.getElementById('loading').style.display = 'none';
        }
    }

    function formatStacks(count) {
        if (count < 64) return count.toString();
        if (count === 64) return '1 x 64';
        const stacks = Math.floor(count / 64);
        const remainder = count % 64;
        return remainder === 0 ? stacks + ' x 64' : stacks + ' x 64 + ' + remainder;
    }

    function parseNBT(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        const readByte = () => view.getInt8(offset++);
        const readShort = () => { const v = view.getInt16(offset); offset += 2; return v; };
        const readInt = () => { const v = view.getInt32(offset); offset += 4; return v; };
        const readLong = () => { const h = view.getInt32(offset), l = view.getInt32(offset + 4); offset += 8; return (BigInt(h) << 32n) | BigInt(l >>> 0); };
        const readString = () => { const len = readShort(); const bytes = new Uint8Array(buffer, offset, len); offset += len; return new TextDecoder().decode(bytes); };

        function readValue(type) {
            switch (type) {
                case 1: return readByte();
                case 2: return readShort();
                case 3: return readInt();
                case 4: return readLong();
                case 8: return readString();
                case 9: return readList();
                case 10: return readCompound();
                case 11: return readIntArray();
                case 12: return readLongArray();
                default: return null;
            }
        }

        function readList() {
            const type = readByte(), length = readInt(), list = [];
            for (let i = 0; i < length; i++) list.push(readValue(type));
            return list;
        }

        function readCompound() {
            const compound = {};
            while (true) {
                const type = readByte();
                if (type === 0) break;
                compound[readString()] = readValue(type);
            }
            return compound;
        }

        function readIntArray() {
            const length = readInt(), array = [];
            for (let i = 0; i < length; i++) array.push(readInt());
            return array;
        }

        function readLongArray() {
            const length = readInt(), array = [];
            for (let i = 0; i < length; i++) array.push(readLong());
            return array;
        }

        readByte();
        readString();
        return readCompound();
    }

    function decodeBlockStates(blockStates, bitsPerEntry, totalBlocks) {
        const blockData = [], mask = (1n << BigInt(bitsPerEntry)) - 1n;
        for (let i = 0; i < totalBlocks; i++) {
            const bitPos = i * bitsPerEntry;
            const longIndex = Math.floor(bitPos / 64);
            const bitOffset = bitPos % 64;
            if (longIndex >= blockStates.length) break;

            let entry = blockStates[longIndex];
            let blockId = Number((entry >> BigInt(bitOffset)) & mask);

            if (bitOffset + bitsPerEntry > 64 && longIndex + 1 < blockStates.length) {
                const bitsInNextLong = (bitOffset + bitsPerEntry) - 64;
                const nextEntry = blockStates[longIndex + 1];
                const nextMask = (1n << BigInt(bitsInNextLong)) - 1n;
                const nextPart = Number(nextEntry & nextMask);
                blockId = blockId | (nextPart << (bitsPerEntry - bitsInNextLong));
            }
            blockData.push(blockId);
        }
        return blockData;
    }

    async function parseLitematic(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const decompressed = pako.ungzip(new Uint8Array(arrayBuffer));
            const nbt = parseNBT(decompressed.buffer);

            litematicBlocks = [];
            const blockCounts = {};

            if (nbt.Regions) {
                for (const regionName in nbt.Regions) {
                    const region = nbt.Regions[regionName];
                    if (!region.BlockStates || !region.BlockStatePalette || !region.Size) continue;

                    const blockStates = region.BlockStates, palette = region.BlockStatePalette, size = region.Size;
                    const width = Math.abs(Number(size.x)), height = Math.abs(Number(size.y)), length = Math.abs(Number(size.z));
                    const totalBlocks = width * height * length;
                    const bitsPerEntry = Math.max(2, Math.ceil(Math.log2(palette.length)));
                    const blocks = decodeBlockStates(blockStates, bitsPerEntry, totalBlocks);

                    blocks.forEach(blockId => {
                        if (blockId >= 0 && blockId < palette.length) {
                            const block = palette[blockId];
                            let blockName = block.Name;
                            if (blockName.toLowerCase().includes('air')) return;
                            blockName = blockName.replace('minecraft:', '').replace('potted_', '').replace(/_/g, ' ');
                            blockName = blockName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                            blockName = RENAME_DICT[blockName] || blockName;
                            if (BLOCKS_WITHOUT_TEXTURES.includes(blockName)) return;
                            blockCounts[blockName] = (blockCounts[blockName] || 0) + 1;
                        }
                    });
                }
            }

            litematicBlocks = Object.entries(blockCounts)
                .map(([name, count]) => ({ name, count, checked: false }))
                .sort((a, b) => b.count - a.count);

            const saved = localStorage.getItem('blockChecks');
            if (saved) {
                const checks = JSON.parse(saved);
                litematicBlocks.forEach(block => {
                    if (checks[block.name] !== undefined) block.checked = checks[block.name];
                });
            }
        } catch (error) {
            console.error('Error parsing litematic:', error);
        }
    }

    function createTextSprite(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;
        context.clearRect(0, 0, 512, 256);
        context.fillStyle = 'white';
        context.font = 'bold 180px Inter, Arial, sans-serif';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 256, 128);

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            depthWrite: false,
            transparent: true
        }));
        sprite.scale.set(6, 3, 1);
        sprite.renderOrder = 1000;
        return sprite;
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        camera = new THREE.PerspectiveCamera(currentFOV, innerWidth / innerHeight, 0.1, 10000);
        
        // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true,
            powerPreference: 'high-performance',
            precision: 'highp',
            alpha: false,
            stencil: false,
            depth: true
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.sortObjects = true;
        renderer.shadowMap.enabled = false; // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –æ—Ç–∫–ª—é—á–∞–µ–º —Ç–µ–Ω–∏
        
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Damping –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.maxDistance = 5000;
        controls.minDistance = 5;
        controls.zoomSpeed = 1.2;
        controls.rotateSpeed = 1.0;
        controls.panSpeed = 0.8;

        controls.addEventListener('start', () => {
            userInteracting = true;
            animating = false;
        });
        controls.addEventListener('end', () => userInteracting = false);
        controls.addEventListener('change', () => cameraMovedSinceLastClick = true);

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        const previewGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const previewMat = new THREE.MeshBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.6,
            depthTest: false
        });
        previewSphere = new THREE.Mesh(previewGeom, previewMat);
        previewSphere.visible = false;
        previewSphere.renderOrder = 999;
        scene.add(previewSphere);

        animate();
    }

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
    function animate() {
        requestAnimationFrame(animate);

        if (animating && !userInteracting) {
            const deltaY = targetCameraY - camera.position.y;
            const deltaTargetY = targetTargetY - controls.target.y;

            if (Math.abs(deltaY) > 0.01 || Math.abs(deltaTargetY) > 0.01) {
                camera.position.y += deltaY * 0.08;
                controls.target.y += deltaTargetY * 0.08;
            } else {
                camera.position.y = targetCameraY;
                controls.target.y = targetTargetY;
                animating = false;
            }
        }

        if (rulerTextSprite && rulerTextSprite.visible) {
            rulerTextSprite.lookAt(camera.position);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    document.getElementById('model-input').addEventListener('change', (e) => {
        if (e.target.files[0]) {
            modelZip = e.target.files[0];
            document.getElementById('model-status').textContent = '‚úì ' + modelZip.name;
            document.getElementById('load-button').style.display = 'inline-flex';
        }
    });

    document.getElementById('litematic-input').addEventListener('change', async (e) => {
        if (e.target.files[0]) {
            litematicFile = e.target.files[0];
            document.getElementById('litematic-status').textContent = '‚úì ' + litematicFile.name;
            await parseLitematic(litematicFile);
            updateMaterialList();
        }
    });

    document.getElementById('texture-input').addEventListener('change', (e) => {
        customTextures = {};
        Array.from(e.target.files).forEach(file => {
            if (file.type.startsWith('image/')) customTextures[file.name] = URL.createObjectURL(file);
        });
        hasCustomTextures = Object.keys(customTextures).length > 0;
        if (hasCustomTextures) document.getElementById('texture-status').textContent = '‚úì ' + Object.keys(customTextures).length + ' files';
    });

    document.getElementById('load-button').addEventListener('click', async () => {
        if (!modelZip) {
            alert('Please select a 3D model ZIP file!');
            return;
        }
        document.getElementById('loading').style.display = 'block';
        document.getElementById('main-content').style.display = 'none';
        if (!scene) initThreeJS();
        await loadModel();
        setTimeout(showDisclaimer, 500);
    });

    async function loadModel() {
        try {
            const zip = await JSZip.loadAsync(modelZip);
            let objContent = null, mtlContent = null;
            defaultTextures = {};

            // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤
            const filePromises = [];
            for (const [filename, file] of Object.entries(zip.files)) {
                if (file.dir) continue;
                const name = filename.toLowerCase();

                if (name.endsWith('.obj')) {
                    filePromises.push(file.async('text').then(content => objContent = content));
                }
                else if (name.endsWith('.mtl')) {
                    filePromises.push(file.async('text').then(content => mtlContent = content));
                }
                else if (name.match(/\.(png|jpg|jpeg)$/i)) {
                    const texName = filename.split('/').pop().split('\\').pop();
                    filePromises.push(
                        file.async('blob').then(blob => defaultTextures[texName] = URL.createObjectURL(blob))
                    );
                }
            }

            await Promise.all(filePromises);

            if (!objContent) { alert('No OBJ file!'); location.reload(); return; }

            if (mtlContent) {
                const lines = mtlContent.split('\n');
                let currentMaterial = null;
                lines.forEach(line => {
                    const t = line.trim();
                    if (t.startsWith('newmtl ')) currentMaterial = t.substring(7).trim();
                    else if (currentMaterial && t.startsWith('map_Kd ')) {
                        textureMap[currentMaterial] = t.substring(7).trim().split('/').pop().split('\\').pop();
                    }
                });
            }

            const manager = new THREE.LoadingManager();
            manager.setURLModifier(url => {
                const fn = url.split('/').pop().split('\\').pop();
                if (defaultTextures[fn]) return defaultTextures[fn];
                for (const [k, v] of Object.entries(defaultTextures)) {
                    if (k.toLowerCase() === fn.toLowerCase()) return v;
                }
                return url;
            });

            const loader = new THREE.OBJLoader(manager);
            if (mtlContent) {
                const mtlLoader = new THREE.MTLLoader(manager);
                const mtls = mtlLoader.parse(mtlContent);
                mtls.preload();
                
                for (const [matName, mat] of Object.entries(mtls.materials)) {
                    mat.side = THREE.DoubleSide;
                    
                    const isTransparent = shouldBeTransparent(matName);
                    mat.transparent = isTransparent;
                    mat.depthWrite = !isTransparent;
                    mat.alphaTest = isTransparent ? 0.1 : 0;
                    mat.opacity = 1.0;
                    
                    if (mat.map) {
                        mat.map.magFilter = THREE.LinearFilter;
                        mat.map.minFilter = THREE.LinearMipMapLinearFilter;
                        mat.map.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                        mat.map.generateMipmaps = false; // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø
                    }
                }
                loader.setMaterials(mtls);
            }

            model = loader.parse(objContent);
            allMeshes = [];
            minY = Infinity; maxY = -Infinity;

            // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ë–∞—Ç—á–∏–Ω–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ—à–µ–π
            model.traverse(child => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const worldPos = vectorPool.get();
                    child.getWorldPosition(worldPos);
                    minY = Math.min(minY, worldPos.y + box.min.y);
                    maxY = Math.max(maxY, worldPos.y + box.max.y);
                    vectorPool.release(worldPos);
                    
                    if (child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(m => {
                            m.side = THREE.DoubleSide;
                            const isTransparent = shouldBeTransparent(m.name);
                            m.transparent = isTransparent;
                            m.depthWrite = !isTransparent;
                            m.alphaTest = isTransparent ? 0.1 : 0;
                            m.opacity = 1.0;
                        });
                    }
                    
                    child.frustumCulled = true;
                    child.matrixAutoUpdate = false; // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø
                    child.updateMatrix();
                }
            });

            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            modelCenter = center;
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            totalLayers = Math.ceil(maxY - minY);
            layerHeight = (maxY - minY) / totalLayers;

            const distance = maxDim * 1.8;
            const elevationAngle = cameraTilt * (Math.PI / 180);
            const azimuthAngle = cameraRotation * (Math.PI / 180);
            const firstLayerY = minY + layerHeight;
            const cameraY = firstLayerY + distance * Math.sin(elevationAngle);
            const horizontalDist = distance * Math.cos(elevationAngle);
            const cameraX = center.x + horizontalDist * Math.cos(azimuthAngle);
            const cameraZ = center.z + horizontalDist * Math.sin(azimuthAngle);

            initialCameraX = cameraX; initialCameraY = cameraY; initialCameraZ = cameraZ;

            camera.position.set(cameraX, cameraY, cameraZ);
            controls.target.set(center.x, firstLayerY, center.z);
            targetCameraY = cameraY;
            targetTargetY = firstLayerY;

            const slider = document.getElementById('layer-slider');
            slider.min = 1; slider.max = totalLayers; slider.value = 1;
            currentLayer = 1; previousLayer = 1;

            updateLayerDisplay();
            updateVisibility();

            if (hasCustomTextures) {
                isCustomMode = true;
                applyTextures();
                document.getElementById('toggle-texture').disabled = false;
                document.getElementById('toggle-texture').classList.add('active');
            }

            if (litematicBlocks.length > 0) updateMaterialList();

            document.getElementById('loading').style.display = 'none';
            document.getElementById('viewer-container').style.display = 'block';
            document.getElementById('layer-info-top').style.display = 'block';
            document.getElementById('arrow-left').style.display = 'flex';
            document.getElementById('arrow-right').style.display = 'flex';
            document.getElementById('material-toggle').style.display = 'flex';
            document.getElementById('right-controls').style.display = 'flex';
            document.getElementById('layer-slider-container').style.display = 'block';
            
            console.log('‚úÖ Model loaded - Meshes:', allMeshes.length, 'Layers:', totalLayers);
        } catch (error) {
            alert('Error: ' + error.message);
            console.error(error);
            location.reload();
        }
    }

    function updateMaterialList() {
        if (typeof window.createMaterialsList === 'function') {
            window.createMaterialsList(litematicBlocks);
        }
    }

    function applyTextures() {
        const currentTextures = isCustomMode ? customTextures : defaultTextures;
        
        // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ë–∞—Ç—á–∏–Ω–≥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Ç–µ–∫—Å—Ç—É—Ä
        requestAnimationFrame(() => {
            allMeshes.forEach(mesh => {
                if (!mesh.material) return;
                const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
                mats.forEach(mat => {
                    if (!mat.name) return;
                    const texName = textureMap[mat.name];
                    if (!texName) return;
                    const cleanTexName = texName.split('/').pop().split('\\').pop();
                    if (currentTextures[cleanTexName]) {
                        const texture = new THREE.TextureLoader().load(currentTextures[cleanTexName]);
                        texture.magFilter = THREE.LinearFilter;
                        texture.minFilter = THREE.LinearMipMapLinearFilter;
                        texture.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 4);
                        texture.generateMipmaps = false;
                        mat.map = texture;
                        
                        const isTransparent = shouldBeTransparent(mat.name);
                        mat.transparent = isTransparent;
                        mat.depthWrite = !isTransparent;
                        mat.alphaTest = isTransparent ? 0.1 : 0;
                        mat.opacity = 1.0;
                        mat.needsUpdate = true;
                    }
                });
            });
        });
    }

    function snapToBlockEdge(point) {
        return new THREE.Vector3(Math.round(point.x), Math.round(point.y), Math.round(point.z));
    }

    function getStraightLine(p1, p2) {
        const dx = Math.abs(p2.x - p1.x), dy = Math.abs(p2.y - p1.y), dz = Math.abs(p2.z - p1.z);
        if (dx >= dy && dx >= dz) return new THREE.Vector3(p2.x, p1.y, p1.z);
        if (dy >= dx && dy >= dz) return new THREE.Vector3(p1.x, p2.y, p1.z);
        return new THREE.Vector3(p1.x, p1.y, p2.z);
    }

    function manhattanDistance(p1, p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) + Math.abs(p1.z - p2.z);
    }

    document.getElementById('ruler-toggle').addEventListener('click', () => {
        rulerActive = !rulerActive;
        const btn = document.getElementById('ruler-toggle');
        if (rulerActive) {
            btn.classList.add('active');
            clearRuler();
        } else {
            btn.classList.remove('active');
            clearRuler();
            previewSphere.visible = false;
        }
    });

    function clearRuler() {
        rulerPoints = [];
        if (rulerLine) { scene.remove(rulerLine); rulerLine = null; }
        if (rulerTextSprite) { scene.remove(rulerTextSprite); rulerTextSprite = null; }
        rulerSpheres.forEach(sphere => scene.remove(sphere));
        rulerSpheres = [];
    }

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Throttle –¥–ª—è mousemove
    let mouseMoveTimeout;
    document.addEventListener('mousemove', (event) => {
        if (!renderer || !renderer.domElement) return;
        
        clearTimeout(mouseMoveTimeout);
        mouseMoveTimeout = setTimeout(() => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
            const intersects = raycaster.intersectObjects(visibleMeshes, false);

            if (rulerActive && rulerPoints.length < 2) {
                if (intersects.length > 0) {
                    const snappedPoint = snapToBlockEdge(intersects[0].point);
                    if (rulerPoints.length === 1) {
                        const straightPoint = getStraightLine(rulerPoints[0], snappedPoint);
                        previewSphere.position.copy(straightPoint);
                    } else {
                        previewSphere.position.copy(snappedPoint);
                    }
                    previewSphere.visible = true;
                } else {
                    previewSphere.visible = false;
                }
            }
        }, 16); // ~60fps throttle
    });

    document.addEventListener('click', (event) => {
        if (!rulerActive || !renderer || !renderer.domElement) return;

        if (rulerPoints.length >= 2) {
            if (!cameraMovedSinceLastClick) {
                clearRuler();
                previewSphere.visible = false;
            }
            cameraMovedSinceLastClick = false;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (intersects.length > 0) {
            const snappedPoint = snapToBlockEdge(intersects[0].point);
            let finalPoint = rulerPoints.length === 1 ? getStraightLine(rulerPoints[0], snappedPoint) : snappedPoint;
            rulerPoints.push(finalPoint);

            const sphereGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            sphere.position.copy(finalPoint);
            sphere.renderOrder = 999;
            scene.add(sphere);
            rulerSpheres.push(sphere);

            if (rulerPoints.length === 2) {
                previewSphere.visible = false;
                const lineGeom = new THREE.BufferGeometry().setFromPoints(rulerPoints);
                const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, depthTest: false });
                rulerLine = new THREE.Line(lineGeom, lineMat);
                rulerLine.renderOrder = 998;
                scene.add(rulerLine);

                const distance = manhattanDistance(rulerPoints[0], rulerPoints[1]);
                const midPoint = new THREE.Vector3().addVectors(rulerPoints[0], rulerPoints[1]).multiplyScalar(0.5);
                rulerTextSprite = createTextSprite(distance.toString());
                rulerTextSprite.position.copy(midPoint);
                rulerTextSprite.position.y += 2;
                scene.add(rulerTextSprite);
                cameraMovedSinceLastClick = false;
            }
        }
    });

    // Touch events (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ)
    let touchMoved = false;
    document.addEventListener('touchstart', () => touchMoved = false);
    document.addEventListener('touchmove', (event) => {
        if (!renderer || !renderer.domElement) return;
        touchMoved = true;

        const rect = renderer.domElement.getBoundingClientRect();
        const touch = event.touches[0];
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (rulerActive && rulerPoints.length < 2 && intersects.length > 0) {
            const snappedPoint = snapToBlockEdge(intersects[0].point);
            if (rulerPoints.length === 1) {
                previewSphere.position.copy(getStraightLine(rulerPoints[0], snappedPoint));
            } else {
                previewSphere.position.copy(snappedPoint);
            }
            previewSphere.visible = true;
        }
    });

    document.addEventListener('touchend', (event) => {
        if (!rulerActive || !renderer || !renderer.domElement || touchMoved) return;

        if (rulerPoints.length >= 2) {
            if (!cameraMovedSinceLastClick) {
                clearRuler();
                previewSphere.visible = false;
            }
            cameraMovedSinceLastClick = false;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        const touch = event.changedTouches[0];
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const visibleMeshes = allMeshes.filter(mesh => mesh.visible);
        const intersects = raycaster.intersectObjects(visibleMeshes, false);

        if (intersects.length > 0) {
            const snappedPoint = snapToBlockEdge(intersects[0].point);
            let finalPoint = rulerPoints.length === 1 ? getStraightLine(rulerPoints[0], snappedPoint) : snappedPoint;
            rulerPoints.push(finalPoint);

            const sphereGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            sphere.position.copy(finalPoint);
            sphere.renderOrder = 999;
            scene.add(sphere);
            rulerSpheres.push(sphere);

            if (rulerPoints.length === 2) {
                previewSphere.visible = false;
                const lineGeom = new THREE.BufferGeometry().setFromPoints(rulerPoints);
                const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, depthTest: false });
                rulerLine = new THREE.Line(lineGeom, lineMat);
                rulerLine.renderOrder = 998;
                scene.add(rulerLine);

                const distance = manhattanDistance(rulerPoints[0], rulerPoints[1]);
                const midPoint = new THREE.Vector3().addVectors(rulerPoints[0], rulerPoints[1]).multiplyScalar(0.5);
                rulerTextSprite = createTextSprite(distance.toString());
                rulerTextSprite.position.copy(midPoint);
                rulerTextSprite.position.y += 2;
                scene.add(rulerTextSprite);
                cameraMovedSinceLastClick = false;
            }
        }
    });

    document.getElementById('toggle-texture').addEventListener('click', () => {
        if (!hasCustomTextures) return;
        isCustomMode = !isCustomMode;
        const btn = document.getElementById('toggle-texture');
        isCustomMode ? btn.classList.add('active') : btn.classList.remove('active');
        applyTextures();
    });

    document.getElementById('material-toggle').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.toggle('active');
    });

    document.getElementById('close-modal').addEventListener('click', () => {
        document.getElementById('material-modal-overlay').classList.remove('active');
    });

    document.getElementById('material-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'material-modal-overlay') {
            document.getElementById('material-modal-overlay').classList.remove('active');
        }
    });

    document.getElementById('fov-toggle').addEventListener('click', () => {
        currentFOV = currentFOV === 40 ? 60 : 40;
        camera.fov = currentFOV;
        camera.updateProjectionMatrix();
        document.getElementById('fov-toggle').classList.toggle('active');
    });

    document.getElementById('share-button')?.addEventListener('click', async () => {
        if (!model || !modelZip) {
            alert('Please load a model first!');
            return;
        }

        document.getElementById('loading').style.display = 'block';

        try {
            const shareZip = new JSZip();
            shareZip.file('model.zip', modelZip);

            if (litematicFile) shareZip.file('litematic.litematic', litematicFile);

            if (hasCustomTextures && Object.keys(customTextures).length > 0) {
                const texturesFolder = shareZip.folder('custom_textures');
                for (const [filename, blobUrl] of Object.entries(customTextures)) {
                    const blob = await fetch(blobUrl).then(r => r.blob());
                    texturesFolder.file(filename, blob);
                }
            }

            const metadata = {
                currentLayer,
                totalLayers,
                hasLitematic: !!litematicFile,
                hasCustomTextures,
                customTexturesCount: Object.keys(customTextures).length,
                timestamp: Date.now()
            };
            shareZip.file('metadata.json', JSON.stringify(metadata));

            const blob = await shareZip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const fileName = 'model-' + Date.now();
            a.download = fileName + '.mcviewer';
            a.click();

            document.getElementById('loading').style.display = 'none';

            let message = '‚úÖ Share file created!\n\n' +
                'üìù Instructions:\n' +
                '1. Upload ' + fileName + '.mcviewer to /shared/ folder\n' +
                '2. Push to GitHub\n' +
                '3. Share link:\n\n' +
                window.location.origin + '/?view=' + fileName;
            
            if (hasCustomTextures) {
                message += '\n\nüé® Textures: ' + Object.keys(customTextures).length;
            }
            
            prompt(message, window.location.origin + '/?view=' + fileName);

        } catch (error) {
            console.error('Share error:', error);
            alert('Error creating share file');
            document.getElementById('loading').style.display = 'none';
        }
    });

    function updateCameraHeight() {
        const layerDifference = currentLayer - previousLayer;
        const yShift = layerDifference * layerHeight;
        targetCameraY = camera.position.y + yShift;
        targetTargetY = controls.target.y + yShift;
        previousLayer = currentLayer;
        animating = true;
    }

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ë–∞—Ç—á–∏–Ω–≥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
    function updateVisibility() {
        const currentMaxY = minY + currentLayer;
        
        requestAnimationFrame(() => {
            const worldPos = vectorPool.get();
            allMeshes.forEach(mesh => {
                mesh.getWorldPosition(worldPos);
                const shouldBeVisible = (worldPos.y + mesh.geometry.boundingBox.max.y) <= currentMaxY + 0.1;
                if (mesh.visible !== shouldBeVisible) {
                    mesh.visible = shouldBeVisible;
                }
            });
            vectorPool.release(worldPos);
        });
    }

    function updateLayerDisplay() {
        document.getElementById('layer-info-top').textContent = 'Layer ' + currentLayer + ' / ' + totalLayers;
    }

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Debounce –¥–ª—è slider
    let sliderTimeout;
    document.getElementById('layer-slider').addEventListener('input', (e) => {
        clearTimeout(sliderTimeout);
        currentLayer = parseInt(e.target.value);
        updateLayerDisplay();
        
        sliderTimeout = setTimeout(() => {
            updateVisibility();
            updateCameraHeight();
        }, 50);
    });

    document.getElementById('arrow-left').addEventListener('click', () => {
        currentLayer = Math.max(currentLayer - 1, 1);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
        currentLayer = Math.min(currentLayer + 1, totalLayers);
        document.getElementById('layer-slider').value = currentLayer;
        updateVisibility();
        updateLayerDisplay();
        updateCameraHeight();
    });

    document.getElementById('reset-camera').addEventListener('click', () => {
        if (model) {
            const currentLayerY = minY + (currentLayer * layerHeight);
            const firstLayerY = minY + layerHeight;
            const yOffset = currentLayerY - firstLayerY;
            camera.position.set(initialCameraX, initialCameraY + yOffset, initialCameraZ);
            controls.target.set(modelCenter.x, firstLayerY + yOffset, modelCenter.z);
            targetCameraY = initialCameraY + yOffset;
            targetTargetY = firstLayerY + yOffset;
            animating = false;
            userInteracting = false;
        }
    });

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: Throttle –¥–ª—è resize
    let resizeTimeout;
    addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (camera && renderer) {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            }
        }, 250);
    });

    addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (camera && renderer) {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            }
        }, 100);
    });
</script>

<script src="src/main.js"></script>
</body>
</html>
